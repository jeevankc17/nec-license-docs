# MCQs

### 1. Intelligence is defined as: \_\_\_\_\_\_

1. The capacity to acquire and apply knowledge.
2. The faculty of thought and reason.
3. Superior powers of mind.
4. All of mentioned above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of mentioned above

**Explanation:**

* Intelligence involves the ability to acquire knowledge, think, reason, and solve problems.
* It also includes superior mental capabilities and the ability to apply knowledge in various situations.

</details>

### 2. Artificial Intelligence (AI) is the simulation of human intelligence by machines. AI has ability to \_\_\_\_\_\_

1. Solve Problems
2. Act Rationally
3. Act like Humans
4. All of mentioned above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of mentioned above

**Explanation:**

* AI is designed to mimic human intelligence, which includes problem-solving, rational decision-making, and acting in ways that resemble human behavior.
* These abilities collectively define the scope of AI.

</details>

### 3. The central principle of AI includes \_\_\_\_\_\_

1. Reasoning, knowledge, planning, learning and communication
2. Perception and the ability to move and manipulate objects.
3. It is the science and engineering of making intelligent machines, especially intelligent computer programs
4. All of the mentioned above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the mentioned above

**Explanation:**

* AI involves reasoning, knowledge representation, planning, learning, and communication.
* It also includes perception and the ability to interact with the environment.
* These principles collectively form the foundation of AI.

</details>

### 4. \_\_\_\_\_\_ is about AI

1. Making a machine Intelligent
2. Putting your intelligence in Machine
3. Programming on Machine with your Own Intelligence
4. Playing a game on Computer

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Making a machine Intelligent

**Explanation:**

* AI focuses on creating systems that can perform tasks that typically require human intelligence, such as learning, reasoning, and problem-solving.
* The goal is to make machines intelligent, not to transfer human intelligence into machines.

</details>

### 5. What is Artificial Intelligence?

1. Artificial Intelligence is a field that aims to make humans more intelligent
2. Artificial Intelligence is a field that aims to collect and mine the data
3. Artificial Intelligence is a field that aims to develop intelligent machines
4. Artificial Intelligence is a field that aims to improve the privacy and security

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Artificial Intelligence is a field that aims to develop intelligent machines

**Explanation:**

* AI is a branch of computer science that focuses on creating machines capable of performing tasks that require human intelligence.
* The primary goal is to develop intelligent machines, not to enhance human intelligence or focus solely on data mining or security.

</details>

### 6. \_\_\_\_\_\_ is the father of Artificial Intelligence

1. Alan Turing
2. John McCarthy
3. Lady ADA
4. Charles Babbage

<details>

<summary>Show me the answer</summary>

**Answer:** 2. John McCarthy

**Explanation:**

* John McCarthy is widely recognized as the father of Artificial Intelligence.
* He coined the term "Artificial Intelligence" in 1956 and made significant contributions to the field.

</details>

### 7. If a machine can change its course of action based on the external environment on its own, the machine is called \_\_\_\_\_\_

1. Ideal
2. Intelligent
3. Both A and B
4. Mobile

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Intelligent

**Explanation:**

* An intelligent machine can adapt its behavior based on changes in the environment.
* This ability to learn and make decisions autonomously is a hallmark of intelligence.

</details>

### 8. \_\_\_\_\_\_ is the branch of Artificial Intelligence.

1. Network Architecture
2. Full Stack Developer
3. Machine Learning
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Machine Learning

**Explanation:**

* Machine Learning is a subset of AI that focuses on the development of algorithms that allow computers to learn from and make predictions based on data.
* It is one of the core branches of AI.

</details>

### 9. \_\_\_\_\_\_ is the goal of an AI

1. To extract scientific causes
2. To solve artificial problems
3. To solve real-world problems
4. To explain various sorts of intelligence

<details>

<summary>Show me the answer</summary>

**Answer:** 3. To solve real-world problems

**Explanation:**

* The primary goal of AI is to develop systems that can solve real-world problems efficiently.
* AI aims to mimic human intelligence to address practical challenges.

</details>

### 10. \_\_\_\_\_\_ is an application of AI

1. It helps to exploit vulnerabilities to secure the firm
2. Easy to create a website
3. It helps to deploy applications on the cloud
4. Language understanding and problem-solving (Text analytics and NLP)

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Language understanding and problem-solving (Text analytics and NLP)

**Explanation:**

* Natural Language Processing (NLP) is a key application of AI that involves understanding and generating human language.
* NLP enables machines to interact with humans in a natural way, solving problems related to language understanding.

</details>

### 11. In how many categories process of Artificial Intelligence is categorized?

1. Processes are categorized based on the provided input and gained output.
2. Categorized into 3 categories
3. Categorized into 4 categories
4. Process is not categorized

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Categorized into 3 categories

**Explanation:**

* The processes in AI are generally categorized into **3 main types**: supervised learning, unsupervised learning, and reinforcement learning.
* These categories are based on how the AI system learns from data.

</details>

### 12. Based on \_\_\_\_\_\_ parameter Artificial Intelligence is categorized.

1. Functionality
2. Durability
3. Capability
4. Both A and C

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both A and C

**Explanation:**

* AI is categorized based on **functionality** (e.g., reactive machines, limited memory, theory of mind, self-awareness).
* It is also categorized based on **capability** (e.g., narrow AI, general AI, super AI).

</details>

### 13. \_\_\_\_\_\_ is not an application of artificial intelligence

1. Computer Vision
2. Natural Language Processing
3. Containerization
4. Image Recognition

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Containerization

**Explanation:**

* **Containerization** is a technology used in software development and deployment, such as Docker.
* It is not directly related to AI, unlike computer vision, NLP, and image recognition.

</details>

### 14. \_\_\_\_\_\_ is the challenges of AI

1. Black box problem
2. AI Algorithm Bias
3. High computing power requirement
4. All of the mentioned above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the mentioned above

**Explanation:**

* AI faces several challenges, including the **black box problem** (lack of transparency in decision-making).
* **Algorithm bias** (biased outcomes due to biased data).
* **High computing power requirements** for training and running AI models.

</details>

### 15. Consider the statement “AI will take over the jobs” is this statement true or its just a myth?

1. Myth
2. Fact
3. May be myth of Fact
4. Neither myth not fact

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Myth

**Explanation:**

* While AI will automate certain tasks, it is unlikely to completely take over jobs.
* Instead, it will transform the nature of work, creating new opportunities and requiring humans to adapt.

</details>

### 16. \_\_\_\_\_\_ is the opensource Open-source AI software.

1. Acumos AI
2. ClearML
3. H2O.ai
4. All of mentioned above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of mentioned above

**Explanation:**

* **Acumos AI**, **ClearML**, and **H2O.ai** are all open-source AI platforms.
* They provide tools for developing and deploying AI models.

</details>

### 17. Which of the given language is not commonly used for AI?

1. LISP
2. PROLOG
3. Python
4. PHP

<details>

<summary>Show me the answer</summary>

**Answer:** 4. PHP

**Explanation:**

* **LISP**, **PROLOG**, and **Python** are commonly used in AI development.
* **PHP** is primarily used for web development and is not commonly associated with AI.

</details>

### 18. An \_\_\_\_\_\_ is anything that can be viewed as perceiving its environment through sensors and acting upon that environment through actuators.

1. Agent
2. Re-agent
3. Perceptor
4. Robotic arm

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Agent

**Explanation:**

* An **agent** in AI is an entity that perceives its environment through sensors and acts upon it through actuators to achieve specific goals.
* This definition aligns with the concept of an intelligent agent.

</details>

### 19. \_\_\_\_\_\_ maps from percept histories to actions: $$f: P^* \rightarrow A$$

1. Perceptor function
2. Agent function
3. Sensor function
4. Actuator function

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Agent function

**Explanation:**

* The **agent function** maps percept histories (sequences of percepts) to actions.
* This function defines the behavior of the agent based on its perception of the environment.

</details>

### 20. The \_\_\_\_\_\_ runs on the physical architecture to produce ‘f’ in this relation $$f: P^* \rightarrow A$$

1. Actuator Program
2. Environment Program
3. Rational Program
4. Agent Program

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Agent Program

**Explanation:**

* The **agent program** runs on the physical architecture to implement the agent function $$f: P^* \rightarrow A$$.
* It determines how the agent behaves based on its percepts.

</details>

### 21. A \_\_\_\_\_\_ should select an action that is expected to maximize its performance measure, based on the evidence provided by the percept sequence and whatever built-in knowledge the agent has.

1. Agent
2. Rational Agent
3. Irrational Agent
4. Environment

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Rational Agent

**Explanation:**

* A **rational agent** selects actions that maximize its performance measure.
* It uses percept sequences and built-in knowledge to make optimal decisions.

</details>

### 22. What is an ‘agent’?

1. Perceives its environment through sensors and acting upon that environment through actuators
2. Takes input from the surroundings and uses its intelligence and performs the desired operations
3. A embedded program controlling line following robot
4. All of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the mentioned

**Explanation:**

* An **agent** perceives its environment through sensors and acts upon it through actuators.
* It uses intelligence to perform operations and can be implemented as an embedded program, such as in a line-following robot.

</details>

### 23. Agents behavior can be best described by \_\_\_\_\_\_.

1. Perception sequence
2. Environment in which agent is performing
3. Sensors and Actuators
4. Agent function

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Agent function

**Explanation:**

* The behavior of an agent is best described by its **agent function**, which maps percept sequences to actions.
* This function defines how the agent responds to its environment.

</details>

### 24. An agent is composed of \_\_\_/Agent’s structure can be viewed as \_\_\_

1. Architecture
2. Agent Function
3. Perception Sequence
4. Architecture and Program

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Architecture and Program

**Explanation:**

* An agent is composed of both **architecture** (the physical hardware) and **program** (the software that implements the agent function).
* Together, they define the agent's structure and behavior.

</details>

### 25. A rational agent is an agent that forever does the right thing.

1. True
2. False
3. Partially true
4. Completely false

<details>

<summary>Show me the answer</summary>

**Answer:** 1. True

**Explanation:**

* A **rational agent** is designed to always select actions that maximize its performance measure.
* It consistently does the "right thing" based on its knowledge and percepts.

</details>

### 26. Performance Measures are not fixed for all agents.

1. True
2. False
3. Partially true
4. Completely false

<details>

<summary>Show me the answer</summary>

**Answer:** 1. True

**Explanation:**

* Performance measures vary depending on the agent's goals and environment.
* Different agents may have different criteria for success.

</details>

### 27. The Task Environment of an agent consists of which of the following?

1. Sensors
2. Performance Measures
3. Actuators
4. All of these

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of these

**Explanation:**

* The **task environment** includes sensors, performance measures, and actuators.
* These components define how the agent interacts with and evaluates its environment.

</details>

### 28. \_\_\_\_\_\_ following is rational at any given time depends on

1. The actions that the agent can do
2. The agent’s previous knowledge of the environment
3. The performance measure that describes the criterion of success
4. All of these

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of these

**Explanation:**

* Rationality depends on the agent's possible actions, its knowledge of the environment, and the performance measure.
* These factors collectively determine the agent's decision-making process.

</details>

### 29. \_\_\_\_\_\_ is the act of task environment and Rational Agents in AI?

1. Observation and Solution
2. Problem and Solution
3. Problem and Observation
4. Identification and Observation

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Problem and Solution

**Explanation:**

* The task environment and rational agents in AI involve identifying problems and finding solutions.
* Rational agents aim to solve problems within their environment.

</details>

### 30. PEAS Stands for \_\_\_\_\_\_ in task Environment.

1. Prediction, Environment, Augmentation, Sensors
2. Perceiving, Entertainment, Actuators, Sense
3. Performance, Environment, Actuators, Sensors
4. Performance, Evolvement, Actuators, Sense

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Performance, Environment, Actuators, Sensors

**Explanation:**

* **PEAS** stands for **Performance, Environment, Actuators, Sensors**.
* It is a framework used to define the task environment of an agent.

</details>

### 31. \_\_\_\_\_\_ is used to select a particular environment when we want to run the agent

1. Environment creator
2. Environment Generator
3. Both A & B
4. None of these

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Environment Generator

**Explanation:**

* An **environment generator** is used to create or select a specific environment for the agent to operate in.
* It allows for controlled testing and simulation of the agent's behavior.

</details>

### 32. Consider an Agent “Taxi Driver” What might be the Performance Measure for it?

1. Comfortable trip
2. Roads
3. Steering Wheels
4. Cameras

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Comfortable trip

**Explanation:**

* For a **taxi driver agent**, the performance measure would likely focus on providing a comfortable and efficient trip for passengers.
* Other options like roads, steering wheels, and cameras are part of the environment, not the performance measure.

</details>

### 33. Consider an Agent “Medical Diagnosis System” What might be the Environments of it?

1. Healthy Patients
2. Patients
3. Hospital
4. Both B and C

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both B and C

**Explanation:**

* The environment for a **medical diagnosis system** includes **patients** and the **hospital** setting.
* These are the contexts in which the system operates.

</details>

### 34. Consider an Agent “Part-picking Robot” What might be the sensors of it?

1. Bins
2. Joined Arms and Hands
3. Camera
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Camera

**Explanation:**

* A **part-picking robot** would likely use **cameras** as sensors to identify and locate parts.
* Bins and arms are part of the robot's physical structure, not sensors.

</details>

### 35. \_\_\_\_\_\_ types of observing environments are there in AI.

1. 1
2. 4
3. 2
4. 3

<details>

<summary>Show me the answer</summary>

**Answer:** 3. 2

**Explanation:**

* There are **two types** of observing environments in AI: **fully observable** and **partially observable**.
* This classification depends on whether the agent can perceive the entire state of the environment.

</details>

### 36. There are \_\_\_\_\_\_ basic types/structures of Agents in AI.

1. 3
2. 5
3. 6
4. 7

<details>

<summary>Show me the answer</summary>

**Answer:** 2. 5

**Explanation:**

* There are **five basic types** of agents in AI: simple reflex agents, model-based reflex agents, goal-based agents, utility-based agents, and learning agents.
* These types differ in their complexity and decision-making processes.

</details>

### 37. Name the type of the agent shown below:

Agent

KNOWLEDGE

LOOK-UP TABLE Key value Percept1 action1 Percept2 action2 ...

Sensors

What the world is like now

What action I should do now

Actuators

Environment

1. Simple reflex agent
2. Model-based agent
3. Goal-based agent
4. Table driven agent

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Table driven agent

**Explanation:**

* The agent uses a **look-up table** to map percepts to actions, which is characteristic of a **table-driven agent**.
* This type of agent relies on pre-defined mappings rather than complex reasoning.

</details>

### 38. Name the type of the agent shown below:

Agent

Condition-action rules

Sensors

What the world is like now

What action I should do now

Actuators

Environment

1. Simple reflex agent
2. Model-based reflect agent
3. Goal-based agent
4. Table driven agent

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Simple reflex agent

**Explanation:**

* The agent uses **condition-action rules** to directly map percepts to actions, which is characteristic of a **simple reflex agent**.
* This type of agent does not maintain an internal model of the world.

</details>

### 39. Name the type of the agent shown below

State How the world evolves What my actions do Condition-action rules What the world is like now What action I should do now

Agent Actuators

1. Simple reflex agent
2. Model-based reflect agent
3. Goal-based agent
4. Table driven agent

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Model-based reflect agent

**Explanation:**

* The agent maintains an internal **state** and uses it to track how the world evolves, which is characteristic of a **model-based reflex agent**.
* This type of agent can handle partially observable environments.

</details>

### 40. Name the type of the agent shown below:

State How the world evolves What my actions do What it will be like if I do action A What the world is like now What action I should do now

Agent Goals Actuators

1. Simple reflex agent
2. Model-based reflect agent
3. Goal-based agent
4. Learning agents

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Goal-based agent

**Explanation:**

* The agent considers **goals** and evaluates the outcomes of its actions, which is characteristic of a **goal-based agent**.
* This type of agent aims to achieve specific objectives.

</details>

### 41. Name the type of the agent shown below:

State How the world evolves What my actions do

Sensors What the world is like now What it will be like if I do action A How happy I will be in such a state What action I should do now

Utility Agent

Actuators

1. Utility-based agent
2. Model-based reflect agent
3. Goal-based agent
4. Learning agents

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Utility-based agent

**Explanation:**

* The agent evaluates actions based on a **utility function**, which measures how "happy" it will be in a given state.
* This is characteristic of a **utility-based agent**.

</details>

### 42. Name the type of the agent shown below:

Performance standard

Critic feedback Learning element learning goals Problem generator Acquiring knowledge Personnel Environment Action Actions

1. Utility-based agent
2. Model-based reflect agent
3. Goal-based agent
4. Learning agents

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Learning agents

**Explanation:**

* The agent includes a **learning element** and a **critic** to improve its performance over time, which is characteristic of a **learning agent**.
* This type of agent adapts based on feedback and experience.

</details>

### 43. Which agent deals with happy and unhappy states?

1. Simple reflex agent
2. Goal based agent
3. Table driven agent
4. Utility based agent

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Utility based agent

**Explanation:**

* A **utility-based agent** evaluates states based on a utility function, which measures how "happy" or "unhappy" the agent is in a given state.
* This allows the agent to make decisions that maximize its overall happiness.

</details>

### 44. In which agent does the problem generator is present?

1. Observing agent
2. Reflex agent
3. Learning agent
4. Simple agent

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Learning agent

**Explanation:**

* A **learning agent** includes a **problem generator** to explore new actions and improve its performance over time.
* This component helps the agent learn from its environment.

</details>

### 45. What is the rule of simple reflex agent?

1. Simple-action rule
2. Condition-action rule
3. Both Simple & Condition-action rule
4. Utility rules

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Condition-action rule

**Explanation:**

* A **simple reflex agent** operates using **condition-action rules**, which directly map percepts to actions.
* These rules are pre-defined and do not involve complex reasoning.

</details>

### 46. The action of the Simple reflex agent completely depends upon \_\_\_\_\_\_.

1. Perception history
2. Current perception
3. Performance measures
4. Goal functions

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Current perception

**Explanation:**

* A **simple reflex agent** bases its actions solely on the **current perception** of the environment.
* It does not consider past perceptions or future consequences.

</details>

### 47. \_\_\_\_\_\_ kind of agent architecture should an agent can use.

1. Relaxed
2. Relational
3. Both A and B
4. None of Above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Both A and B

**Explanation:**

* An agent can use both **relaxed** and **relational** architectures depending on the task and environment.
* These architectures provide flexibility in how the agent processes information and makes decisions.

</details>

### 48. An agent’s sensors give it access to complete state of the environment at each point in time, then we say that the task environment is \_\_\_\_\_\_.

1. Partially observable
2. Fully observable
3. Static
4. Deterministic

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Fully observable

**Explanation:**

* If an agent's sensors provide complete access to the environment's state at all times, the environment is **fully observable**.
* This means the agent has all the information it needs to make decisions.

</details>

### 49. Consider an example of a Chess game, in which a player gets to see the whole board. Which environment is this?

1. Partially observable
2. Fully observable
3. Static
4. Deterministic

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Fully observable

**Explanation:**

* In a **chess game**, the player can see the entire board, making the environment **fully observable**.
* The player has complete information about the game state at all times.

</details>

### 50. Consider an example of poker game, in which a player gets to see only his cards. Which environment is this?

1. Partially observable
2. Fully observable
3. Static
4. Deterministic

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Partially observable

**Explanation:**

* In a **poker game**, a player can only see their own cards, making the environment **partially observable**.
* The player does not have complete information about the game state.

</details>

### 51. If the next state of the environment is completely determined by the current state and the actions of the agent, then the environment is \_\_\_\_\_\_.

1. Deterministic
2. Non-Deterministic
3. Random
4. Static

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Deterministic

**Explanation:**

* In a **deterministic environment**, the next state is entirely determined by the current state and the agent's actions.
* There is no randomness or uncertainty in the outcome.

</details>

### 52. Tic-Tac-Toe game is the example of \_\_\_\_\_\_ environment.

1. Random
2. Dynamic
3. Deterministic
4. Non-Deterministic

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Deterministic

**Explanation:**

* In **Tic-Tac-Toe**, the next state of the game is entirely determined by the current state and the player's move.
* This makes it a **deterministic environment**.

</details>

### 53. Self-driving vehicles are an example of \_\_\_\_\_\_ AI processes.

1. Non-deterministic/Stochastic
2. Deterministic
3. Fully observable
4. Partially observable

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Non-deterministic/Stochastic

**Explanation:**

* Self-driving vehicles operate in **non-deterministic** or **stochastic** environments because they must deal with unpredictable factors like other drivers, pedestrians, and weather conditions.
* The outcomes of their actions are not always certain.

</details>

### 54. In Episodic Environment, Experience is divided into \_\_\_\_\_\_ of agents perceiving then acting. Action taken in one \_\_\_\_\_\_ does not affect next one at all.

1. Epochs
2. Episodes
3. Time frames
4. Half

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Episodes

**Explanation:**

* In an **episodic environment**, the agent's experience is divided into **episodes**, where each episode is independent of the others.
* Actions taken in one episode do not affect the next.

</details>

### 55. E-mail sorting system is an example of \_\_\_\_\_\_.

1. Episodic Environment
2. Static Environment
3. Non-Deterministic Environment
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Episodic Environment

**Explanation:**

* An **email sorting system** operates in an **episodic environment** because each email is processed independently.
* The sorting of one email does not affect the sorting of the next.

</details>

### 56. Chess Game is an example of \_\_\_\_\_\_.

1. Episodic Environment
2. Static Environment
3. Non-Episodic Environment
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Non-Episodic Environment

**Explanation:**

* A **chess game** is a **non-episodic environment** because each move affects the state of the game and influences future moves.
* The game is continuous and interconnected.

</details>

### 57. The environment is \_\_\_\_\_\_ if current decisions affect future decisions, or rely on previous ones.

1. Sequential/Non-Episodic
2. Static
3. Dynamic
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Sequential/Non-Episodic

**Explanation:**

* In a **sequential** or **non-episodic environment**, current decisions affect future decisions, and the agent must consider the history of its actions.
* This is common in games like chess or real-world planning tasks.

</details>

### 58. If the environment does not change while an agent is acting, then it is \_\_\_\_\_\_; otherwise, it is \_\_\_\_\_\_.

1. Static, Dynamic
2. Static, Deterministic
3. Dynamic, Static
4. Dynamic, Deterministic

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Static, Dynamic

**Explanation:**

* A **static environment** does not change while the agent is acting, whereas a **dynamic environment** changes over time.
* This distinction is important for designing agents that can adapt to their surroundings.

</details>

### 59. Consider an example, if we add 2+2=4 this will remain same they will never be change. Which environment is this?

1. Static
2. Dynamic
3. Sequential
4. Deterministic

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Static

**Explanation:**

* The equation $$2 + 2 = 4$$ is a **static environment** because it does not change over time.
* The result is always the same, regardless of when or how it is calculated.

</details>

### 60. Consider an example of playing football game, in every action there will be new reaction. Which environment is this?

1. Static
2. Dynamic
3. Sequential
4. Deterministic

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Dynamic

**Explanation:**

* A **football game** is a **dynamic environment** because the state of the game changes continuously with each action.
* Players must constantly adapt to new situations.

</details>

### 61. If there are a limited number of distinct, clearly defined, states of the environment, the environment is \_\_\_\_\_\_.

1. Discrete
2. Continuous
3. Static
4. Dynamic

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Discrete

**Explanation:**

* A **discrete environment** has a finite number of distinct states, each clearly defined.
* This is in contrast to a continuous environment, where states can vary infinitely.

</details>

### 62. Consider an example of a game of chess or checkers where there are a set number of moves. Which environment is this?

1. Discrete
2. Continuous
3. Static
4. Dynamic

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Discrete

**Explanation:**

* Games like **chess** and **checkers** have a finite number of possible moves and states, making them **discrete environments**.
* The game progresses through a series of distinct states.

</details>

### 63. Signals constantly coming into sensors, actions continually changing is \_\_\_\_\_\_ environment.

1. Discrete
2. Continuous
3. Static
4. Deterministic

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Continuous

**Explanation:**

* A **continuous environment** involves signals and actions that change continuously over time.
* This is common in real-world systems like self-driving cars or robotics.

</details>

### 64. Consider an example, Taxi driving. In which there could be a route from to anywhere to anywhere else. Which environment is this?

1. Discrete
2. Continuous
3. Static
4. Deterministic

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Continuous

**Explanation:**

* **Taxi driving** involves navigating through a **continuous environment**, where routes and positions can vary infinitely.
* The environment is not limited to a finite set of states.

</details>

### 65. \_\_\_\_\_\_ is not Properties of Environment.

1. Discrete / Continuous
2. Static / Dynamic
3. Deterministic / Non-deterministic
4. No agent / Multiple agents

<details>

<summary>Show me the answer</summary>

**Answer:** 4. No agent / Multiple agents

**Explanation:**

* The properties of an environment include whether it is **discrete/continuous**, **static/dynamic**, and **deterministic/non-deterministic**.
* The presence or absence of agents is not a property of the environment itself.

</details>

### 66. What kind of environment is crossword puzzle?

1. Dynamic
2. Static
3. Semi Dynamic
4. Observable

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Static

**Explanation:**

* A **crossword puzzle** is a **static environment** because the puzzle does not change while the solver is working on it.
* The solver's actions do not alter the puzzle itself.

</details>

### 67. \_\_\_\_\_\_ environment is called as semi dynamic.

1. Environment does not change with the passage of time
2. Agent performance changes
3. Environment does not change with the passage of time, but Agent performance changes
4. Environment will be changed

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Environment does not change with the passage of time, but Agent performance changes

**Explanation:**

* A **semi-dynamic environment** is one where the environment itself does not change over time, but the agent's performance or actions may change.
* This is a hybrid between static and dynamic environments.

</details>

### 68. An agent's sensors give it access to the complete state of the environment at each point in time is \_\_\_\_\_\_.

1. Fully observable environment
2. Partially observable environment
3. Stochastic Environment
4. Dynamic Environment

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Fully observable environment

**Explanation:**

* If an agent's sensors provide complete access to the environment's state at all times, the environment is **fully observable**.
* The agent has all the information it needs to make decisions.

</details>

### 69. Environment can change while agent is thinking is \_\_\_\_\_\_.

1. Static Environment
2. Dynamic Environment
3. Deterministic Environment
4. Sequential Environment

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Dynamic Environment

**Explanation:**

* In a **dynamic environment**, the environment can change while the agent is thinking or acting.
* This requires the agent to adapt to new situations in real-time.

</details>

### 70. Environment does not change with time but, but performance score does is \_\_\_\_\_\_.

1. Dynamic Environment
2. Semi-Dynamic Environment
3. Deterministic Environment
4. Sequential Environment

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Semi-Dynamic Environment

**Explanation:**

* A **semi-dynamic environment** is one where the environment itself does not change over time, but the agent's performance or score may change.
* This is a hybrid between static and dynamic environments.

</details>

### 71. An agent operating by itself in an environment is \_\_\_\_\_\_.

1. Single Agent
2. Multi-Agent
3. Intelligent Agent
4. Rational Agent

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Single Agent

**Explanation:**

* A **single agent** operates independently in an environment without interacting with other agents.
* This is in contrast to a multi-agent system, where multiple agents interact.

</details>

### 72. What kind of agent is a Web Crawler?

1. Table-driven agent
2. Utility-based agent
3. Learning agent
4. Intelligent goal-based agent

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Intelligent goal-based agent

**Explanation:**

* A **web crawler** is an **intelligent goal-based agent** because it is designed to achieve specific goals, such as indexing web pages.
* It uses intelligent algorithms to navigate and collect data from the web.

</details>

### 73. \_\_\_\_\_\_ is the main task of a problem-solving agent.

1. Solve the given problem and reach to goal
2. To find out which sequence of action will get it to the goal state
3. All of the mentioned
4. None of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 3. All of the mentioned

**Explanation:**

* The main task of a **problem-solving agent** is to solve the given problem and reach the goal.
* This involves finding the sequence of actions that will lead to the goal state.

</details>

### 74. \_\_\_\_\_\_ is a process of generating solution from an observed data.

1. Problem generating
2. Problem Solving
3. Problem Identifying
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Problem Solving

**Explanation:**

* **Problem solving** involves generating solutions based on observed data or information.
* It is a key task for intelligent agents in AI.

</details>

### 75. Problem solving is characterized by \_\_\_\_\_\_.

1. A set of goals
2. Set of objects
3. Set of operations
4. All of the mentioned above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the mentioned above

**Explanation:**

* Problem solving is characterized by a **set of goals**, a **set of objects**, and a **set of operations** that can be performed to achieve the goals.
* These elements define the problem space.

</details>

### 76. Problem space is an \_\_\_\_\_\_ space.

1. Virtual
2. Abstract
3. Search
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Abstract

**Explanation:**

* The **problem space** is an **abstract representation** of the problem, including all possible states and actions.
* It is used by the agent to explore and find solutions.

</details>

### 77. The solution to the problem space is \_\_\_\_\_\_.

1. Combination of operations and objects that achieve the goals.
2. Combination of Abstract space and objects that achieve the goals.
3. Combination of Problem and solution that achieve the goals.
4. Combination of Operation and Abstract space that achieve the goals.

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Combination of operations and objects that achieve the goals.

**Explanation:**

* The solution to a problem space involves finding the **combination of operations and objects** that achieve the desired goals.
* This is the essence of problem-solving in AI.

</details>

### 78. Search refers to the search for a \_\_\_\_\_\_ in a problem space.

1. Problem
2. Solution
3. Idea
4. Knowledge

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Solution

**Explanation:**

* **Search** in AI refers to the process of finding a **solution** within the problem space.
* The agent explores possible states and actions to reach the goal.

</details>

### 79. To build a system to solve a particular problem, we need to \_\_\_\_\_\_.

1. Define the problem
2. Analyze the problem
3. Isolate and represent task knowledge necessary to solve the problem
4. Choose the best problem-solving technique and apply to the particular problem
5. All of above mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 5. All of above mentioned

**Explanation:**

* To build a problem-solving system, we need to **define the problem**, **analyze it**, **represent the necessary knowledge**, and **choose the best technique** to solve it.
* These steps are essential for effective problem-solving in AI.

</details>

### 80. A \_\_\_\_\_\_ is defined by its elements and their relations.

1. Solution
2. Problem
3. Reason
4. Idea

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Problem

**Explanation:**

* A **problem** is defined by its **elements** (e.g., objects, goals) and the **relations** between them.
* This definition helps the agent understand and solve the problem.

</details>

### 81. \_\_\_\_\_\_ is a representation of element at given moment.

1. State
2. Space
3. Search
4. Problem

<details>

<summary>Show me the answer</summary>

**Answer:** 1. State

**Explanation:**

* A **state** represents the configuration of elements in the problem space at a given moment.
* It is a snapshot of the problem at a specific point in time.

</details>

### 82. \_\_\_\_\_\_ is needed for state change.

1. Successor function
2. Compressor function
3. Generalization function
4. Abstract function

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Successor function

**Explanation:**

* The **successor function** is used to generate new states from the current state by applying actions.
* It is essential for exploring the problem space and finding solutions.

</details>

### 83. A \_\_\_\_\_\_ is a set of all states, reachable from initial state.

1. Search space
2. State space
3. Problem space
4. None

<details>

<summary>Show me the answer</summary>

**Answer:** 2. State space

**Explanation:**

* The **state space** is the set of all possible states that can be reached from the initial state by applying actions.
* It represents the entire problem space that the agent can explore.

</details>

### 84. The structure of state space is \_\_\_\_\_\_ and \_\_\_\_\_\_.

1. Root node and leaf nodes
2. Tree and Graph
3. Tree and Forest
4. Forest and Graph

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Tree and Graph

**Explanation:**

* The **state space** can be represented as a **tree** or a **graph**, depending on the problem.
* Trees are used for problems with a hierarchical structure, while graphs are used for more complex relationships.

</details>

### 85. \_\_\_\_\_\_ explores the state space.

1. State process
2. Search process
3. Problem process
4. Successor function

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Search process

**Explanation:**

* The **search process** explores the state space to find a path from the initial state to the goal state.
* It involves evaluating and selecting actions to reach the solution.

</details>

### 86. In \_\_\_\_\_\_ the search explores, all possible path between the initial state and the goal state.

1. Best case
2. Worst case
3. Average case
4. All case

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Worst case

**Explanation:**

* In the **worst case**, the search process explores all possible paths between the initial state and the goal state.
* This occurs when the search algorithm does not use heuristics or other optimizations.

</details>

### 87. In the state space, a \_\_\_\_\_\_ is a path from the initial state to the goal state or sometime just the goal state.

1. Problem
2. Solution
3. Search
4. Process

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Solution

**Explanation:**

* A **solution** in the state space is a path from the initial state to the goal state.
* It represents the sequence of actions that solve the problem.

</details>

### 88. A problem consists of description of \_\_\_\_\_\_.

1. Current state
2. Action
3. Desired state
4. All of them

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of them

**Explanation:**

* A problem consists of the **current state**, the **actions** that can be taken, and the **desired state** (goal).
* These elements define the problem and guide the search for a solution.

</details>

### 89. What is Initial state + Goal state in Search Terminology?

1. Problem Space
2. Problem Instance
3. Search Space Graph
4. Admissibility

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Problem Instance

**Explanation:**

* In search terminology, the combination of the **initial state** and the **goal state** is called a **problem instance**.
* It defines the specific problem to be solved.

</details>

### 90. Which of the following is the process of eliminating the detail from a given state representation?

1. Extraction
2. Exploration
3. Association
4. Abstraction

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Abstraction

**Explanation:**

* **Abstraction** is the process of removing unnecessary details from a state representation to simplify the problem.
* It helps focus on the essential aspects of the problem.

</details>

### 91. A \_\_\_\_\_\_ is Deterministic, fully observable, known, discrete in nature.

1. Search space problem
2. State space problem
3. Conformant Problem
4. Contingency Problem

<details>

<summary>Show me the answer</summary>

**Answer:** 2. State space problem

**Explanation:**

* A **state space problem** is deterministic, fully observable, known, and discrete.
* These properties make it easier to model and solve using search algorithms.

</details>

### 92. A \_\_\_\_\_\_ is non-observable in nature.

1. Search space problem
2. State space problem
3. Conformant Problem
4. Contingency Problem

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Conformant Problem

**Explanation:**

* A **conformant problem** is one where the agent cannot observe the state of the environment directly.
* The agent must act based on incomplete or uncertain information.

</details>

### 93. A \_\_\_\_\_\_ is non-deterministic and/or partially observable in nature.

1. Search space problem
2. State space problem
3. Conformant Problem
4. Contingency Problem

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Contingency Problem

**Explanation:**

* A **contingency problem** involves non-deterministic and/or partially observable environments.
* The agent must handle uncertainty and adapt to changing conditions.

</details>

### 94. A \_\_\_\_\_\_ is unknown state space.

1. Exploration problem
2. State space problem
3. Conformant Problem
4. Contingency Problem

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Exploration problem

**Explanation:**

* An **exploration problem** involves an unknown state space, where the agent must explore and learn about the environment as it acts.
* This is common in reinforcement learning and robotics.

</details>

### 95. \_\_\_\_\_\_ are the components of well-defined problems.

1. Initial state and available actions given by the successor functions.
2. Goal test
3. Path cost
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* A **well-defined problem** includes the **initial state**, **available actions**, **goal test**, and **path cost**.
* These components are necessary for defining and solving the problem.

</details>

### 96. Search algorithm are commonly evaluated in terms of:

1. Completeness, Time Complexity, Space Complexity, Optimality
2. Preparedness, Time Complexity, Space Complexity, Admissibility
3. Completeness, Constant Complexity, Logarithmic Complexity, Optimality
4. Preparedness, Time Complexity, Quadratic Complexity, Admissibility

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Completeness, Time Complexity, Space Complexity, Optimality

**Explanation:**

* Search algorithms are evaluated based on **completeness** (whether they find a solution if one exists), **time complexity** (how long it takes to find a solution), **space complexity** (how much memory is required), and **optimality** (whether the solution is the best possible).
* These criteria help determine the efficiency and effectiveness of the algorithm.

</details>

### 97. \_\_\_\_\_\_ and \_\_\_\_\_\_ complexity is measured in terms of:

b- max branching factor of the search tree\
d- depth of the least-cost solution\
m- maximum depth of the search tree

1. Time, Space Complexity
2. Constant, Logarithmic Complexity
3. Time, Quadratic Complexity
4. Space, Logarithmic Complexity

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Time, Space Complexity

**Explanation:**

* **Time complexity** and **space complexity** are measured in terms of the **branching factor (b)**, **depth of the least-cost solution (d)**, and **maximum depth of the search tree (m)**.
* These parameters help analyze the efficiency of search algorithms.

</details>

### 98. A \_\_\_\_\_\_ is a searching technique that has no additional information about the distance from the current state to the goal.

1. Informed Search
2. Uninformed Search
3. Random Search
4. Binary Search

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Uninformed Search

**Explanation:**

* **Uninformed search** techniques, such as breadth-first search and depth-first search, do not use additional information about the distance to the goal.
* They explore the state space blindly.

</details>

### 99. A \_\_\_\_\_\_ is a searching technique that has additional information about the estimate distance from the current state to the goal.

1. Informed Search
2. Uninformed Search
3. Random Search
4. Binary Search

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Informed Search

**Explanation:**

* **Informed search** techniques, such as A\* search, use additional information (heuristics) to estimate the distance to the goal.
* This helps guide the search more efficiently.

</details>

### 100. \_\_\_\_\_\_ search uses knowledge to find out the steps to the solutions

1. Informed Search
2. Uninformed Search
3. Random Search
4. Binary Search

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Informed Search

**Explanation:**

* **Informed search** uses knowledge, such as heuristics, to find the steps to the solution.
* This makes the search process more efficient compared to uninformed search.

</details>

1. 10 expanded nodes are: S, A, D, E, G, C, E, B, C, G
2. 10 expanded nodes are: S, S, B, E, D, C, A, B, C, G
3. 10 expanded nodes are: S, S, D, G, A, S, B, C, E, G
4. 10 expanded nodes are: S, S, A, B, C, S, A, D, E, G

<details>

<summary>Show me the answer</summary>

**Answer:** 4. 10 expanded nodes are: S, S, A, B, C, S, A, D, E, G

**Explanation:**

* **Iterative Deepening Search** combines DFS and BFS by iteratively increasing the depth limit.
* The order of expansion would be: S → S → A → B → C → S → A → D → E → G.

</details>

### 134. \_\_\_\_\_\_ is similar to Hill climbing searching but with revising or backtracking.

1. Depth first search
2. Breadth first search
3. Best first search
4. Binary Search

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Best first search

**Explanation:**

* **Best-First Search** is similar to Hill Climbing but allows for revising or backtracking.
* It uses a heuristic function to guide the search.

</details>

### 135. The best first search uses the concept of a \_\_\_\_\_\_ and heuristic search.

1. Circular queue
2. Linear queue
3. Priority queue
4. Stack

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Priority queue

**Explanation:**

* **Best-First Search** uses a **priority queue** to prioritize nodes based on a heuristic function.
* This ensures that the most promising nodes are explored first.

</details>

### 136. \_\_\_\_\_\_ is the time and \_\_\_\_\_\_ is the space complexity of Best first search. Where b= branching factor and d= depth.

1. $$O(b^{d-1})$$, $$O(b^{d-1})$$
2. $$O(b^{d+1})$$, $$O(b^{d+1})$$
3. $$O(b^{d-1})$$, $$O(b^{d+1})$$
4. $$O(bd^2)$$, $$O(bd)$$

<details>

<summary>Show me the answer</summary>

**Answer:** 1. $$O(b^{d-1})$$, $$O(b^{d-1})$$

**Explanation:**

* The **time complexity** of Best-First Search is $$O(b^{d-1})$$.
* The **space complexity** is also $$O(b^{d-1})$$ because it stores nodes in the priority queue.

</details>

### 137. Greedy best first search evaluates nodes by using only \_\_\_\_\_\_

1. Linear function
2. Non-linear function
3. Friend function
4. Heuristic function

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Heuristic function

**Explanation:**

* **Greedy Best-First Search** evaluates nodes using only a **heuristic function**.
* This function estimates the cost to reach the goal from the current node.

</details>

### 138. Why greedy best first search is not complete?

1. Because it can override the heuristic function
2. Because it can traverse to outer loop
3. Because it can get stuck in loop
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Because it can get stuck in loop

**Explanation:**

* **Greedy Best-First Search** is **not complete** because it can get stuck in loops.
* It does not guarantee finding a solution if one exists.

</details>

### 139. \_\_\_\_\_\_ is the time and \_\_\_\_\_\_ is the space complexity of Greedy Best first search.

1. $$O(bm)$$, $$O(b^{m})$$
2. $$O(b^{m})$$, $$O(bm)$$
3. $$O(b^{m+1})$$, $$O(b^{m+1})$$
4. $$O(b^{m})$$, $$O(b^{m})$$

<details>

<summary>Show me the answer</summary>

**Answer:** 4. $$O(b^{m})$$, $$O(b^{m})$$

**Explanation:**

* The **time complexity** of Greedy Best-First Search is $$O(b^{m})$$.
* The **space complexity** is also $$O(b^{m})$$ because it stores nodes in the priority queue.

</details>

### 140. The main idea of A\* searching is to a \_\_\_\_\_\_

1. Do not expand expensive path
2. Expand expensive path
3. All path cost are same in searching
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Do not expand expensive path

**Explanation:**

* The main idea of _A Search_\* is to avoid expanding expensive paths by using a heuristic function.
* It combines the cost to reach the current node and the estimated cost to reach the goal.

</details>

### 141. Evaluation function is \_\_\_\_\_\_ for A\* searching, where, g(n) - cost so far to reach n h(n) - estimated cost to goal from n f(n) - estimated total cost of path through n to goal.

1. $$f(n) = g(n) / h(n)$$
2. $$f(n) = g(n) - h(n)$$
3. $$f(n) = g(n) + h(n)$$
4. $$f(n) = g(n) \times h(n)$$

<details>

<summary>Show me the answer</summary>

**Answer:** 3. $$f(n) = g(n) + h(n)$$

**Explanation:**

* The **evaluation function** in A\* Search is $$f(n) = g(n) + h(n)$$.
* Here, $$g(n)$$ is the cost to reach node $$n$$, and $$h(n)$$ is the estimated cost to reach the goal from $$n$$.

</details>

### 142. A\* search uses an \_\_\_\_\_\_ heuristic; that is, h(n) < h\*(n) where h\*(n) is the true cost from ‘n’.

1. Non- admissible
2. Admissible
3. Anchoring
4. Constant

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Admissible

**Explanation:**

* _A Search_\* uses an **admissible heuristic**, meaning $$h(n) < h^*(n)$$.
* This ensures that the heuristic never overestimates the true cost to reach the goal.

</details>

### 143. When should A\* searching terminate?

1. After we enqueue a goal
2. After we dequeue a goal
3. No enqueue and dequeue
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. After we dequeue a goal

**Explanation:**

* _A Search_\* terminates when a goal node is **dequeued** from the priority queue.
* This ensures that the optimal path has been found.

</details>

### 144. A\* search theorem states that:

1. If h(n) is not admissible, A\* using TREE-SEARCH is optimal.
2. If h(n) is admissible, A\* using TREE-SEARCH is optimal.
3. If h(n) is admissible, A\* using TREE-SEARCH is not optimal.
4. If h(n) is not admissible, A\* using TREE-SEARCH is also not optimal.

<details>

<summary>Show me the answer</summary>

**Answer:** 2. If h(n) is admissible, A\* using TREE-SEARCH is optimal.

**Explanation:**

* The _A Search Theorem_\* states that if the heuristic $$h(n)$$ is **admissible**, A\* using TREE-SEARCH is **optimal**.
* This means it will find the least-cost path to the goal.

</details>

### 145. \_\_\_\_\_\_ is the time and \_\_\_\_\_\_ is the space complexity of A\* Search. Where b= branching factor and d= depth

1. $$O(b^{d+1})$$, $$O(b^b)$$
2. $$O(b^b)$$, $$O(b^b)$$
3. $$O(b^{d+1})$$, $$O(b^{d+1})$$
4. $$O(b^b)$$, $$O(b^{d+1})$$

<details>

<summary>Show me the answer</summary>

**Answer:** 2. $$O(b^b)$$, $$O(b^b)$$

**Explanation:**

* The **time complexity** of A\* Search is $$O(b^b)$$.
* The **space complexity** is also $$O(b^b)$$ because it stores nodes in the priority queue.

</details>

### 146. A\* is an admissible algorithm that \_\_\_\_\_\_ optimal solution.

1. Does not guarantee
2. Guarantee
3. Partially guarantee
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Guarantee

**Explanation:**

* _A Search_\* is an **admissible algorithm** that **guarantees** an optimal solution.
* It finds the least-cost path to the goal if the heuristic is admissible.

</details>

### 147. The main application of A\* Search Algorithm is: Path/ Routing problems can be solved by using A\* Searching algorithm.

1. True
2. False
3. Partially True
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. True

**Explanation:**

* _A Search_\* is widely used for solving **pathfinding** and **routing problems**.
* It is efficient and guarantees the optimal path if the heuristic is admissible.

</details>

### 148. A\* using Tree search is optimal if heuristic is \_\_\_\_\_\_.

1. Constant
2. Admissible
3. Anchoring
4. Representative

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Admissible

**Explanation:**

* _A Search_\* using Tree Search is **optimal** if the heuristic is **admissible**.
* This means the heuristic never overestimates the true cost to reach the goal.

</details>

### 149. A\* using Graph search is optimal if heuristic is \_\_\_\_\_\_.

1. Constant
2. Admissible
3. Representative
4. Anchoring

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Admissible

**Explanation:**

* _A Search_\* using Graph Search is **optimal** if the heuristic is **admissible**.
* This ensures that the algorithm finds the least-cost path to the goal.

</details>

### 150. \_\_\_\_\_\_ is sometimes called greedy local search because it grabs a good neighbor state without thinking ahead about where to go next.

1. Mini Max
2. Alpha beta pruning
3. Hill Climbing
4. BFS

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Hill Climbing

**Explanation:**

* **Hill Climbing** is sometimes called **greedy local search** because it selects the best neighbor state without considering future steps.
* It focuses on immediate improvements rather than long-term planning.

</details>

### 151. Main features of hill climbing algorithm is \_\_\_\_\_\_.

1. Generate and test variant
2. No back tracking
3. Greedy approach
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Hill Climbing** is a **generate-and-test variant** that does not backtrack.
* It uses a **greedy approach** to move towards the best neighbor state.

</details>

### 152. \_\_\_\_\_\_ is the problem in Hill climbing searching.

1. Local Maximum
2. Plateau
3. Ridges
4. All of mentioned above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of mentioned above

**Explanation:**

* **Hill Climbing** can get stuck in **local maxima**, **plateaus**, and **ridges**.
* These are common problems that prevent the algorithm from finding the global optimum.

</details>

### 153. In \_\_\_\_\_\_ we escape local maxima by allowing some "bad" moves but gradually decrease their frequency.

1. Hill Climbing
2. Simulated Annealing
3. Mini max
4. Alpha beta pruning

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Simulated Annealing

**Explanation:**

* **Simulated Annealing** allows some "bad" moves to escape local maxima.
* The frequency of these moves decreases over time, helping the algorithm converge to the global optimum.

</details>

### 154. Simulated Annealing is \_\_\_\_\_\_ optimization technique.

1. Local
2. Global
3. Both Local and Global
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Global

**Explanation:**

* **Simulated Annealing** is a **global optimization technique**.
* It is designed to find the global optimum by exploring the search space more thoroughly.

</details>

### 155. Simulated Annealing is a \_\_\_\_\_\_ algorithm, the algorithm does not use any information gathered during the search.

1. Memory equipped
2. Memory less
3. Processor equipped
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Memory less

**Explanation:**

* **Simulated Annealing** is a **memoryless algorithm**.
* It does not use any information gathered during the search to guide future moves.

</details>

### 156. The process of annealing can be simulated with the metropolis algorithm which is based on \_\_\_\_\_\_ techniques.

1. Closed form solution
2. Monte-Carlo simulation
3. Numerical Transformation Method
4. Proposed Method

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Monte-Carlo simulation

**Explanation:**

* The **Metropolis Algorithm** used in Simulated Annealing is based on **Monte-Carlo simulation** techniques.
* It uses random sampling to explore the search space.

</details>

### 157. Adversarial Search uses \_\_\_\_\_\_ environment

1. Collective
2. Competitive
3. Cooperative
4. Both Collective and Cooperative

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Competitive

**Explanation:**

* **Adversarial Search** is used in **competitive environments** where multiple agents compete against each other.
* Examples include games like chess and tic-tac-toe.

</details>

### 158. General game involves \_\_\_\_\_\_ agents

1. Multi
2. Single
3. Only single and multi
4. Neither single nor multi

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Only single and multi

**Explanation:**

* **General games** can involve either **single-agent** or **multi-agent** scenarios.
* The nature of the game determines the number of agents involved.

</details>

### 159. \_\_\_\_\_\_ search methods only consider how close the agent is to the goal state.

1. Multi-agent
2. Single-agent
3. Both single and multi-agent
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Single-agent

**Explanation:**

* **Single-agent search methods** focus on how close the agent is to the goal state.
* They do not consider the actions of other agents.

</details>

### 160. In \_\_\_\_\_\_ games, decisions of both agents have to be taken into account: a decision made by one agent will affect the resulting search space that the other agent would need to explore.

1. Single player
2. Two-player
3. No Player
4. Both Single and Two player

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Two-player

**Explanation:**

* In **two-player games**, the decisions of both agents affect the search space.
* Each agent's move influences the possible moves of the other agent.

</details>

### 161. To formalize a two-player game as a search problem an agent can be called \_\_\_\_\_\_ and the opponent can be called \_\_\_\_\_\_.

1. MINI, MAX
2. MAX, MIN
3. MIN, MIN
4. MAX, MAX

<details>

<summary>Show me the answer</summary>

**Answer:** 2. MAX, MIN

**Explanation:**

* In **two-player games**, the agent is often called **MAX** (aiming to maximize its score), and the opponent is called **MIN** (aiming to minimize the agent's score).
* This is the basis of the **Minimax Algorithm**.

</details>

### 162. MINI MAX Algorithm is perfect for deterministic and is a \_\_\_\_\_\_ game.

1. Single player (Computer)
2. Two-player (Computer and User)
3. Single player (User)
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Two-player (Computer and User)

**Explanation:**

* The **Minimax Algorithm** is perfect for **deterministic two-player games**.
* It is commonly used in games like chess and tic-tac-toe.

</details>

### 163. Free cell, 8-puzzle, Rubrik’s cube is an example of \_\_\_\_\_\_.

1. Deterministic Multi player
2. Deterministic Single player
3. Non-Deterministic single player
4. Non-deterministic multi player

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Deterministic Single player

**Explanation:**

* **Free cell**, **8-puzzle**, and **Rubik’s cube** are examples of **deterministic single-player games**.
* The outcome is determined solely by the player's actions.

</details>

### 164. Tic-tac-toe, Chess, Checker is a example of \_\_\_\_\_\_.

1. Deterministic Multi player
2. Deterministic Single player
3. Non-Deterministic single player
4. Non-deterministic multi player

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Deterministic Multi player

**Explanation:**

* **Tic-tac-toe**, **chess**, and **checkers** are examples of **deterministic multi-player games**.
* The outcome depends on the actions of both players.

</details>

### 165. In \_\_\_\_\_\_ game, one player maximize result, another player minimize result.

1. Zero-player
2. One-player
3. Two-player
4. Thee-player

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Two-player

**Explanation:**

* In **two-player games**, one player aims to **maximize** their result, while the other aims to **minimize** it.
* This is the basis of the **Minimax Algorithm**.

</details>

### 166. \_\_\_\_\_\_ is the time and \_\_\_\_\_\_ is the space complexity of MINI MAX Algorithm.

1. $$O(b^m)$$, $$O(bm)$$
2. $$O(b^{m+1})$$, $$O(bm)$$
3. $$O(b^m)$$, $$O(b^m)$$
4. $$O(bm)$$, $$O(b^m)$$

<details>

<summary>Show me the answer</summary>

**Answer:** 1. $$O(b^m)$$, $$O(bm)$$

**Explanation:**

* The **time complexity** of the Minimax Algorithm is $$O(b^m)$$, where $$b$$ is the branching factor and $$m$$ is the maximum depth.
* The **space complexity** is $$O(bm)$$ because it stores the current path in the stack.

</details>

### 167. The minimax algorithm performs a complete \_\_\_\_\_\_ exploration of the game tree.

1. Breadth-first
2. Depth-first
3. Best-first
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Depth-first

**Explanation:**

* The **Minimax Algorithm** performs a **depth-first exploration** of the game tree.
* It explores each branch to the maximum depth before backtracking.

</details>

### 168. Is MINI MAX Search complete if tree is finite?

1. May be
2. No
3. Yes
4. Rather not say

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Yes

**Explanation:**

* **Minimax Search** is **complete** if the game tree is finite.
* It will eventually find the optimal solution if one exists.

</details>

### 169. For making decision of win/lose, we apply \_\_\_\_\_\_ algorithm on game tree.

1. Greedy search Algorithm
2. Hill Climbing Algorithm
3. Mini Max Algorithm
4. BFS/DFS Algorithm

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Mini Max Algorithm

**Explanation:**

* The **Minimax Algorithm** is used to make decisions about winning or losing in game trees.
* It evaluates all possible moves to determine the best strategy.

</details>

### 170. In Alpha-Beta Pruning Algorithm, Pruning \_\_\_\_\_\_ the final result.

1. Might affect
2. Does not affect
3. Affect
4. Sometime affects, sometime doesn’t affect

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Does not affect

**Explanation:**

* **Alpha-Beta Pruning** does not affect the final result.
* It only reduces the number of nodes evaluated, improving efficiency without changing the outcome.

</details>

### 171. Why it is called Alpha-Beta? α is the value of the best \_\_\_\_\_\_ choice found so far at any choice point along the path for max.

1. Lowest value
2. Average value
3. Highest value
4. Infinite value

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Highest value

**Explanation:**

* In **Alpha-Beta Pruning**, $$\alpha$$ represents the **highest value** choice found so far for the MAX player.
* $$\beta$$ represents the **lowest value** choice found so far for the MIN player.

</details>

### 172. \_\_\_\_\_\_ is a modified version of the Mini Max Algorithm.

1. Hill climbing
2. Alpha beta pruning
3. BFS
4. DFS

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Alpha beta pruning

**Explanation:**

* **Alpha-Beta Pruning** is a modified version of the **Minimax Algorithm**.
* It reduces the number of nodes evaluated by pruning branches that cannot influence the final decision.

</details>

### 173. To \_\_\_\_\_\_ depth does the alpha-beta pruning can be applied.

1. 12 states
2. 5 States
3. 1 States
4. Any depth

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Any depth

**Explanation:**

* **Alpha-Beta Pruning** can be applied to **any depth** in the game tree.
* It is not limited to a specific number of states or levels.

</details>

### 174. In alpha-beta pruning, the initial value of alpha is \_\_\_\_\_\_ and beta is \_\_\_\_\_\_.

1. Negative Infinity, Positive Infinity
2. -1, +1
3. Positive Infinity, Negative Infinity
4. +1, -1

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Negative Infinity, Positive Infinity

**Explanation:**

* In **Alpha-Beta Pruning**, the initial value of $$\alpha$$ is **negative infinity**, and $$\beta$$ is **positive infinity**.
* These values are updated as the algorithm explores the game tree.

</details>

### 175. The main condition which required for alpha-beta pruning is?

1. alpha>=beta
2. alpha=beta
3. alpha<=bet
4. alpha!=beta

<details>

<summary>Show me the answer</summary>

**Answer:** 1. alpha>=beta

**Explanation:**

* The main condition for **Alpha-Beta Pruning** is $$\alpha \geq \beta$$.
* When this condition is met, the algorithm prunes the remaining branches.

</details>

### 176. The 2 types of move ordering in Alpha-Beta Pruning are \_\_\_\_\_\_ and \_\_\_\_\_\_.

1. Best ordering, Ideal Ordering
2. Worst ordering, Ideal Ordering
3. Best ordering, Random Ordering
4. Worst ordering, Random Ordering

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Worst ordering, Ideal Ordering

**Explanation:**

* The two types of move ordering in **Alpha-Beta Pruning** are **worst ordering** and **ideal ordering**.
* Ideal ordering maximizes pruning efficiency, while worst ordering minimizes it.

</details>

### 177. In Alpha-Beta pruning, With "perfect ordering," time complexity = \_\_\_\_\_\_.

1. $$O(b^{m/2})$$
2. $$O(b^{m+1/2})$$
3. $$O(b^m)$$
4. $$O(bm)$$

<details>

<summary>Show me the answer</summary>

**Answer:** 1. $$O(b^{m/2})$$

**Explanation:**

* With **perfect ordering**, the **time complexity** of Alpha-Beta Pruning is $$O(b^{m/2})$$.
* This significantly reduces the number of nodes evaluated compared to Minimax.

</details>

### 178. Identify the type of knowledge in Artificial Intelligence.

1. Procedural and Declarative Knowledge
2. Meta Knowledge
3. Structural and Heuristic Knowledge
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* In AI, knowledge can be **procedural**, **declarative**, **meta**, **structural**, or **heuristic**.
* These types of knowledge are used to represent and reason about information in AI systems.

</details>

### 179. \_\_\_\_\_\_ Knowledge is also known as Imperative Knowledge.

1. Procedural
2. Meta
3. Structural
4. Heuristic

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Procedural

**Explanation:**

* **Procedural Knowledge** is also known as **Imperative Knowledge**.
* It involves knowing how to perform tasks or procedures.

</details>

### 180. \_\_\_\_\_\_ is non procedural, independent of targets and problem solving.

1. Procedural Knowledge
2. Declarative Knowledge
3. Meta Knowledge
4. Structural Knowledge

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Declarative Knowledge

**Explanation:**

* **Declarative Knowledge** is non-procedural and independent of specific targets or problem-solving methods.
* It involves knowing facts and information.

</details>

### 181. \_\_\_\_\_\_ is a knowledge about knowledge and how to gain them.

1. Procedural Knowledge
2. Declarative Knowledge
3. Meta Knowledge
4. Structural Knowledge

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Meta Knowledge

**Explanation:**

* **Meta Knowledge** is knowledge about knowledge and how to acquire it.
* It involves understanding the nature and structure of knowledge itself.

</details>

### 182. \_\_\_\_\_\_ represents a knowledge of some experts in a field or subject.

1. Procedural Knowledge
2. Declarative Knowledge
3. Heuristic Knowledge
4. Structural Knowledge

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Heuristic Knowledge

**Explanation:**

* **Heuristic Knowledge** represents the knowledge of experts in a field or subject.
* It involves rules of thumb and practical strategies for problem-solving.

</details>

### 183. \_\_\_\_\_\_ talks about what relationship exists between concept/objects.

1. Procedural Knowledge
2. Declarative Knowledge
3. Heuristic Knowledge
4. Structural Knowledge

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Structural Knowledge

**Explanation:**

* **Structural Knowledge** describes the relationships between concepts or objects.
* It involves understanding how different elements are connected.

</details>

### 184. Knowledge Representation and Reasoning represents information from the real world for a computer to understand and then utilize this knowledge to solve \_\_\_\_\_\_.

1. Simplest real-life problems
2. Complex real-life problems
3. Neither simplest nor complex problems
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Complex real-life problems

**Explanation:**

* **Knowledge Representation and Reasoning** is used to represent real-world information in a way that computers can understand.
* This knowledge is then utilized to solve **complex real-life problems**.

</details>

### 185. Different kinds of knowledge that need to be represented in AI are \_\_\_\_\_\_.

1. Object, Events, Performance, Facts
2. Knowledge base
3. Meta knowledge
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* In AI, knowledge about **objects**, **events**, **performance**, **facts**, **knowledge bases**, and **meta knowledge** needs to be represented.
* These types of knowledge are essential for reasoning and problem-solving.

</details>

### 186. \_\_\_\_\_\_ is the technique of knowledge representation in AI

1. Logical Representation
2. Semantic Network and Frame Representation
3. Production Rules
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* **Logical Representation**, **Semantic Networks**, **Frame Representation**, and **Production Rules** are all techniques used for knowledge representation in AI.
* These techniques help in organizing and reasoning about knowledge.

</details>

### 187. \_\_\_\_\_\_ is a language with some definite rules which deal with propositions & has no ambiguity in representation.

1. Semantic Network representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Logical Representation

**Explanation:**

* **Logical Representation** is a language with definite rules that deal with propositions.
* It ensures there is no ambiguity in the representation of knowledge.

</details>

### 188. In order to give information to agent and get info without errors in communication, we use \_\_\_\_\_\_ technique of knowledge representation.

1. Semantic Network representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Logical Representation

**Explanation:**

* **Logical Representation** is used to give information to agents and retrieve it without errors.
* It provides a clear and unambiguous way to represent knowledge.

</details>

### 189. \_\_\_\_\_\_ work as an alternative of predicate logic for knowledge representation.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Semantic Network Representation

**Explanation:**

* **Semantic Network Representation** is an alternative to predicate logic for knowledge representation.
* It uses nodes and links to represent relationships between concepts.

</details>

### 190. \_\_\_\_\_\_ knowledge representation consists of < condition, action > pairs

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Production Rules

**Explanation:**

* **Production Rules** consist of < condition, action > pairs.
* These rules are used to represent knowledge in a way that can be easily applied to solve problems.

</details>

### 191. \_\_\_\_\_\_ is a knowledge representation technique where knowledge is represented as a set of objects and their attributes.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Frame Representation

**Explanation:**

* **Frame Representation** is a knowledge representation technique where knowledge is represented as a set of objects and their attributes.
* It is similar to object-oriented programming.

</details>

### 192. \_\_\_\_\_\_ is a knowledge representation technique where knowledge is represented as a graph of nodes and links.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Semantic Network Representation

**Explanation:**

* **Semantic Network Representation** uses a graph of nodes and links to represent knowledge.
* Nodes represent concepts, and links represent relationships between them.

</details>

### 193. \_\_\_\_\_\_ is a knowledge representation technique where knowledge is represented as a set of rules.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Production Rules

**Explanation:**

* **Production Rules** represent knowledge as a set of rules.
* These rules are used to infer new knowledge from existing knowledge.

</details>

### 194. \_\_\_\_\_\_ is a knowledge representation technique where knowledge is represented as a set of logical statements.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Logical Representation

**Explanation:**

* **Logical Representation** uses logical statements to represent knowledge.
* It is based on formal logic and provides a precise way to represent information.

</details>

### 195. \_\_\_\_\_\_ is a knowledge representation technique where knowledge is represented as a set of frames.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Frame Representation

**Explanation:**

* **Frame Representation** uses frames to represent knowledge.
* Each frame contains slots that represent attributes of an object or concept.

</details>

### 196. \_\_\_\_\_\_ is a knowledge representation technique where knowledge is represented as a set of if-then rules.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Production Rules

**Explanation:**

* **Production Rules** represent knowledge as a set of if-then rules.
* These rules are used to infer new knowledge from existing knowledge.

</details>

### 197. \_\_\_\_\_\_ is a knowledge representation technique where knowledge is represented as a set of nodes and links.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Semantic Network Representation

**Explanation:**

* **Semantic Network Representation** uses nodes and links to represent knowledge.
* Nodes represent concepts, and links represent relationships between them.

</details>

### 198. \_\_\_\_\_\_ is a knowledge representation technique where knowledge is represented as a set of logical statements.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Logical Representation

**Explanation:**

* **Logical Representation** uses logical statements to represent knowledge.
* It is based on formal logic and provides a precise way to represent information.

</details>

### 199. \_\_\_\_\_\_ is a knowledge representation technique where knowledge is represented as a set of frames.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Frame Representation

**Explanation:**

* **Frame Representation** uses frames to represent knowledge.
* Each frame contains slots that represent attributes of an object or concept.

</details>

### 200. \_\_\_\_\_\_ is a knowledge representation technique where knowledge is represented as a set of if-then rules.

1. Semantic Network Representation
2. Logical Representation
3. Frame Representation
4. Production Rules

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Production Rules

**Explanation:**

* **Production Rules** represent knowledge as a set of if-then rules.
* These rules are used to infer new knowledge from existing knowledge.

</details>

### 201. \_\_\_\_\_\_ may be either true or false but not other value.

1. Proposition
2. Predicate
3. Quantifier
4. Inference

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Proposition

**Explanation:**

* A **proposition** is a statement that is either true or false, but not both.
* It is a declarative sentence that can be evaluated as true or false.

</details>

### 202. \_\_\_\_\_\_ is the type of the proposition.

1. Simple
2. Compound
3. Both A and B
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Both A and B

**Explanation:**

* Propositions can be **simple** (atomic) or **compound** (composed of multiple propositions connected by logical operators).
* Both types are valid in logic.

</details>

### 203. \_\_\_\_\_\_ are formed from atomic formulas using the logical connectives not, or, if...then, and, if and only if etc.

1. Simple Proposition
2. Compound Proposition
3. Existential Proposition
4. Non-existential Proposition

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Compound Proposition

**Explanation:**

* **Compound propositions** are formed by combining atomic propositions using logical connectives such as AND, OR, NOT, IF...THEN, and IF AND ONLY IF.
* These connectives allow for the creation of more complex logical expressions.

</details>

### 204. Identify the examples of proposition and state which proposition is this.

Eg1: It is raining.\
Eg2: Snow is white.

1. Simple Proposition
2. Compound Proposition
3. Existential Proposition
4. Non-existential Proposition

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Simple Proposition

**Explanation:**

* Both examples are **simple propositions** because they are single, declarative statements that can be evaluated as true or false.
* They do not contain any logical connectives or multiple propositions.

</details>

### 205. Identify the examples of propositions and state which proposition is this.

Eg1. If you study hard you will be rewarded.\
Eg2. The sum of 10 and 20 is not 50.

1. Simple Proposition
2. Compound Proposition
3. Existential Proposition
4. Non-existential Proposition

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Compound Proposition

**Explanation:**

* Both examples are **compound propositions** because they involve logical connectives.
* Eg1 uses "if...then," and Eg2 uses "not," making them compound propositions.

</details>

### 206. Which is used to construct the complex sentences?

1. Connectives
2. Symbols
3. Logical connectives
4. Semantics

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Logical connectives

**Explanation:**

* **Logical connectives** such as AND, OR, NOT, IF...THEN, and IF AND ONLY IF are used to construct complex sentences from simpler propositions.
* These connectives allow for the creation of more sophisticated logical expressions.

</details>

### 207. \_\_\_\_\_\_ is the logical operator.

1. Negation
2. Conjunction
3. Both A and B
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Both A and B

**Explanation:**

* **Negation** (NOT) and **conjunction** (AND) are both logical operators.
* They are used to manipulate and combine propositions in logical expressions.

</details>

### 208. Consider, the proposition P, Identify which logical connectives is this? -P (read "not P")

1. Conjunction
2. Disjunction
3. Negation
4. Exclusive OR

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Negation

**Explanation:**

* The symbol **-P** represents the **negation** of the proposition P.
* Negation is a logical operator that inverts the truth value of a proposition.

</details>

### 209. Consider, P and Q be the propositions, Identify which logical connectives is this? PAQ (read "P and Q")

1. Conjunction
2. Disjunction
3. Negation
4. Exclusive OR

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Conjunction

**Explanation:**

* The expression **PAQ** represents the **conjunction** of P and Q, meaning "P and Q."
* Conjunction is a logical operator that is true only if both P and Q are true.

</details>

### 210. Consider, P and Q be the propositions, Identify which logical connectives is this? PVQ (read "P or Q")

1. Conjunction
2. Disjunction
3. Negation
4. Exclusive OR

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Disjunction

**Explanation:**

* The expression **PVQ** represents the **disjunction** of P and Q, meaning "P or Q."
* Disjunction is a logical operator that is true if at least one of P or Q is true.

</details>

### 211. Consider, P and Q be the propositions, Identify which statement is true for this relation. P→Q (read "P implies Q")

1. Implication of P from Q
2. Implication of Q from P
3. Biconditional from P to Q
4. Biconditional from Q to P

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Implication of Q from P

**Explanation:**

* The expression **P→Q** represents the **implication** of Q from P, meaning "if P is true, then Q is true."
* It is a conditional statement where P is the hypothesis, and Q is the conclusion.

</details>

### 212. Consider, P and Q be the propositions, Identify which logical operator is this? P@Q

1. Conjunction
2. Disjunction
3. Negation
4. Exclusive OR

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Exclusive OR

**Explanation:**

* The symbol **P@Q** typically represents the **exclusive OR** (XOR) operation.
* XOR is true if either P or Q is true, but not both.

</details>

### 213. Suppose, P and Q be the propositions. In \_\_\_\_\_\_ statement P→Q, P is called hypothesis (premise or antecedent) and Q is called conclusion or consequence.

1. Simple Statement
2. Conditional Statement
3. Both A and B
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Conditional Statement

**Explanation:**

* The statement **P→Q** is a **conditional statement**, where P is the hypothesis (antecedent), and Q is the conclusion (consequent).
* It represents a logical implication.

</details>

### 214. The conditional statement of P→Q is

1. “if P, then Q”
2. “if P, Q”
3. “P is sufficient for Q”
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* The conditional statement **P→Q** can be expressed in multiple ways, including "if P, then Q," "if P, Q," and "P is sufficient for Q."
* All these forms are valid representations of the implication.

</details>

### 215. To form the \_\_\_\_\_\_ of the conditional statement, interchange the hypothesis and the conclusion. The \_\_\_\_\_\_ of "If it rains, then they cancel hiking" is "If they cancel hiking, then it rains."

1. Converse, Inverse
2. Converse, Converse
3. Inverse, Converse
4. Converse, Contrapositive

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Converse, Converse

**Explanation:**

* The **converse** of a conditional statement is formed by interchanging the hypothesis and the conclusion.
* For example, the converse of "If it rains, then they cancel hiking" is "If they cancel hiking, then it rains."

</details>

### 216. To form the \_\_\_\_\_\_ of the conditional statement, take the negation of both the hypothesis and the conclusion. The \_\_\_\_\_\_ of "If it rains, then they cancel hiking" is "If it does not rain, then they do not cancel hiking."

1. Inverse, Converse
2. Converse, Inverse
3. Inverse, Inverse
4. Converse, Converse

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Inverse, Inverse

**Explanation:**

* The **inverse** of a conditional statement is formed by negating both the hypothesis and the conclusion.
* For example, the inverse of "If it rains, then they cancel hiking" is "If it does not rain, then they do not cancel hiking."

</details>

### 217. To form the \_\_\_\_\_\_ of the conditional statement, interchange the hypothesis and the conclusion of the inverse statement. The \_\_\_\_\_\_ of "If it rains, then they cancel hiking" is "If they do not cancel hiking, then it does not rain."

1. Contrapositive, Contrapositive
2. Converse, Inverse
3. Inverse, Inverse
4. Converse, Converse

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Contrapositive, Contrapositive

**Explanation:**

* The **contrapositive** of a conditional statement is formed by interchanging the hypothesis and the conclusion of the inverse statement.
* For example, the contrapositive of "If it rains, then they cancel hiking" is "If they do not cancel hiking, then it does not rain."

</details>

### 218. Let P and Q be Propositions, In \_\_\_\_\_\_ statement P←→Q, the proposition is "if P and only if Q"

1. Atomic Statement
2. Conditional Statement
3. Bi-conditional Statement
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Bi-conditional Statement

**Explanation:**

* The statement **P←→Q** is a **bi-conditional statement**, meaning "P if and only if Q."
* It is true when both P and Q have the same truth value.

</details>

### 219. The conditional statement of P←→Q is

1. “p is necessary and sufficient for q”
2. “if p then q, and conversely”
3. “p iff q”
4. “p if and only if q”
5. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 5. All of above

**Explanation:**

* The bi-conditional statement **P←→Q** can be expressed in multiple ways, including "p is necessary and sufficient for q," "if p then q, and conversely," "p iff q," and "p if and only if q."
* All these forms are valid representations of the bi-conditional statement.

</details>

### 220. A proposition that is always true is called a \_\_\_\_\_\_

1. Contradiction
2. Contingency
3. Tautology
4. Hypothesis

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Tautology

**Explanation:**

* A **tautology** is a proposition that is always true, regardless of the truth values of its components.
* It is a statement that is logically valid in all cases.

</details>

### 221. A proposition that is always false is called a \_\_\_\_\_\_

1. Contradiction
2. Contingency
3. Tautology
4. Hypothesis

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Contradiction

**Explanation:**

* A **contradiction** is a proposition that is always false, regardless of the truth values of its components.
* It is a statement that is logically invalid in all cases.

</details>

### 222. A proposition is called a \_\_\_\_\_\_, if that proposition is neither a tautology nor a contradiction.

1. Contradiction
2. Contingency
3. Tautology
4. Hypothesis

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Contingency

**Explanation:**

* A **contingency** is a proposition that is neither a tautology nor a contradiction.
* Its truth value depends on the truth values of its components.

</details>

### 223. Every complete "sentence" contains two parts: a \_\_\_\_\_\_ and a \_\_\_\_\_\_

1. Object, contingency
2. Object, predicate
3. Object, Hypothesis
4. Object, Tautology

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Object, predicate

**Explanation:**

* In logic, a complete sentence consists of an **object** (the subject) and a **predicate** (the property or relation associated with the object).
* For example, in "The sky is blue," "the sky" is the object, and "is blue" is the predicate.

</details>

### 224. Consider an example and identify the predicate.

"The car Ram is driving is red":\
"The sky is red":\
"The cover of this book is red":

1. The predicate is “is red”
2. The predicate is “is driving”
3. The predicate is “the sky”
4. The predicate is “this book”

<details>

<summary>Show me the answer</summary>

**Answer:** 1. The predicate is “is red”

**Explanation:**

* In all three examples, the predicate is "is red," as it describes the property of the object.
* The predicate is the part of the sentence that provides information about the subject.

</details>

### 225. A \_\_\_\_\_\_ is a property that a variable or a finite collection of variables can have.

1. Tautology
2. Predicate
3. Proposition
4. Implication

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Predicate

**Explanation:**

* A **predicate** is a property or relation that can be applied to variables or objects.
* For example, in "x is red," "is red" is the predicate applied to the variable x.

</details>

### 226. P, P^Q, P \rightarrow Q, \neg Q etc. These are the examples of \_\_\_\_\_\_

1. Proof
2. Validity
3. Well-formed-formula
4. Inference

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Well-formed-formula

**Explanation:**

* **Well-formed formulas (WFFs)** are syntactically correct expressions in logic.
* Examples include P, P^Q, P→Q, and ¬Q, which are valid logical expressions.

</details>

### 227. A language element which generates a quantification (such as "every") is called a \_\_\_\_\_\_

1. Proof
2. Quantifier
3. Inference
4. Tautology

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Quantifier

**Explanation:**

* A **quantifier** is a language element that specifies the quantity of a variable in a logical expression.
* Examples include "every," "some," and "all."

</details>

### 228. Two types of quantifiers, which are called the \_\_\_\_\_\_ and the \_\_\_\_\_\_ quantifiers, can quantify the open statements p(x) and q(x,y).

1. Existential
2. Universal
3. Conditional
4. Both A and B

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both A and B

**Explanation:**

* The two main types of quantifiers are **existential** (e.g., "there exists") and **universal** (e.g., "for all").
* These quantifiers are used to specify the scope of variables in logical expressions.

</details>

### 229. The \_\_\_\_\_\_ quantifier (means "for some x", "for at least one x", or "there exists an x such that"); "for some x, p(x)" is denoted as "∃x, p(x)".

1. Universal
2. Existential
3. Conditional
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Existential

**Explanation:**

* The **existential quantifier** (∃) is used to express that there exists at least one value of x for which p(x) is true.
* It is denoted as "∃x, p(x)."

</details>

### 230. The \_\_\_\_\_\_ quantifier (means "for all x", "for any x", "for each x", or "for every x"): "for all x, all y" is denoted by "∀x ∀y".

1. Universal
2. Existential
3. Conditional
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Universal

**Explanation:**

* The **universal quantifier** (∀) is used to express that a statement is true for all values of x.
* It is denoted as "∀x, p(x)."

</details>

### 231. The \_\_\_\_\_\_ of propositional logic provide the means to perform logical proofs or deductions.

1. Inference rules
2. Commutativity rules
3. Associativity rules
4. Idempotency rules

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Inference rules

**Explanation:**

* **Inference rules** are used in propositional logic to derive conclusions from premises.
* Examples include modus ponens, modus tollens, and hypothetical syllogism.

</details>

### 232. \_\_\_\_\_\_ are the types of inference rules.

1. Modus ponens
2. Modus tollens
3. Both A and B
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Both A and B

**Explanation:**

* **Modus ponens** and **modus tollens** are both types of inference rules used in logical reasoning.
* They are fundamental to deductive reasoning.

</details>

### 233. If P and P \rightarrow Q are both true, we can infer that Q will be true as well in \_\_\_\_\_\_

1. Modus ponens
2. Modus tollens
3. Hypothetical syllogism
4. Disjunctive syllogism

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Modus ponens

**Explanation:**

* **Modus ponens** is an inference rule that states if P is true and P→Q is true, then Q must also be true.
* It is a fundamental rule in logical reasoning.

</details>

### 234. If P \rightarrow Q is true and \neg Q is true, then \neg P will also true in \_\_\_\_\_\_

1. Modus ponens
2. Modus tollens
3. Hypothetical syllogism
4. Disjunctive syllogism

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Modus tollens

**Explanation:**

* **Modus tollens** is an inference rule that states if P→Q is true and ¬Q is true, then ¬P must also be true.
* It is the contrapositive of modus ponens.

</details>

### 235. If P \rightarrow R is true whenever P \rightarrow Q is true, and Q \rightarrow R is true in \_\_\_\_\_\_

1. Modus ponens
2. Modus tollens
3. Hypothetical syllogism
4. Disjunctive syllogism

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Hypothetical syllogism

**Explanation:**

* **Hypothetical syllogism** is an inference rule that states if P→Q and Q→R are true, then P→R must also be true.
* It is used to chain implications together.

</details>

### 236. If PVQ is true, and \neg P is true, then Q will be true in \_\_\_\_\_\_

1. Modus ponens
2. Modus tollens
3. Hypothetical syllogism
4. Disjunctive syllogism

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Disjunctive syllogism

**Explanation:**

* **Disjunctive syllogism** is an inference rule that states if PVQ is true and ¬P is true, then Q must also be true.
* It is used to eliminate one of the disjuncts in a logical disjunction.

</details>

### 237. If P is true, then PVQ will be true in \_\_\_\_\_\_

1. Modus ponens
2. Modus tollens
3. Addition
4. Disjunctive syllogism

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Addition

**Explanation:**

* **Addition** is an inference rule that states if P is true, then PVQ must also be true, regardless of the truth value of Q.
* It is used to introduce a disjunction.

</details>

### 238. If PA Q is true, then Q or P will also be true in \_\_\_\_\_\_

1. Modus ponens
2. Addition
3. Simplification
4. Resolution

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Simplification

**Explanation:**

* **Simplification** is an inference rule that states if PAQ is true, then both P and Q must also be true.
* It is used to break down a conjunction into its individual components.

</details>

### 239. If PVQ and \neg PAR is true, then QVR will also be true in \_\_\_\_\_\_

1. Modus ponens
2. Addition
3. Simplification
4. Resolution

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Resolution

**Explanation:**

* **Resolution** is an inference rule that combines two clauses to produce a new clause.
* In this case, PVQ and ¬PAR resolve to QVR.

</details>

### 240. \_\_\_\_\_\_ is a process of making two different logical atomic expressions identical by finding a substitution.

1. Quantification
2. Unification
3. Resolution
4. Simplification

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Unification

**Explanation:**

* **Unification** is the process of finding a substitution that makes two logical expressions identical.
* It is a key step in many logical inference algorithms, such as resolution.

</details>

### 241. Which is also called single inference rule?

1. Modus Ponens
2. Resolution
3. Modus Tollens
4. Conjunction

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Resolution

**Explanation:**

* **Resolution** is often referred to as a single inference rule because it can be used to derive conclusions from a set of clauses without requiring multiple steps.
* It is a powerful and widely used rule in automated theorem proving.

</details>

### 242. FOPL was developed to extend the expressiveness of \_\_\_\_\_\_.

1. Predicate logic
2. Propositional logic
3. Tautology
4. Quantifiers

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Propositional logic

**Explanation:**

* **First-Order Predicate Logic (FOPL)** was developed to extend the expressiveness of **propositional logic** by introducing quantifiers and predicates.
* This allows for more complex and nuanced logical expressions.

</details>

### 243. Consider the following logic and state if this is valid or not.

Example:\
If All men are mortal = P\
Socrates is a Man = Q\
Socrates is mortal = R\
Then (P & Q) → R

1. Valid
2. Invalid
3. Partially valid
4. Rather not say

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Valid

**Explanation:**

* The argument is **valid** because if all men are mortal (P) and Socrates is a man (Q), then it logically follows that Socrates is mortal (R).
* This is a classic example of a valid syllogism.

</details>

### 244. First Order Predicate Logic (FOPL) is also known as \_\_\_\_\_\_.

1. First Order Predicate Calculus
2. Quantification Theory
3. Lower Order Calculus
4. All of the mentioned above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the mentioned above

**Explanation:**

* **First-Order Predicate Logic (FOPL)** is also known as **First-Order Predicate Calculus**, **Quantification Theory**, and **Lower Order Calculus**.
* These terms are often used interchangeably to refer to the same logical system.

</details>

### 245. In FOPL, constants, variables and functions are known as \_\_\_\_\_\_.

1. Lists
2. Terms
3. Atoms
4. Literals

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Terms

**Explanation:**

* In **First-Order Predicate Logic (FOPL)**, **constants**, **variables**, and **functions** are collectively referred to as **terms**.
* Terms are the basic building blocks of logical expressions in FOPL.

</details>

### 246. In FOPL, predicates are referred to as atomic formulas or \_\_\_\_\_\_.

1. Lists
2. Terms
3. Atoms
4. Literals

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Atoms

**Explanation:**

* In **First-Order Predicate Logic (FOPL)**, **predicates** are referred to as **atomic formulas** or **atoms**.
* These are the simplest forms of logical expressions that cannot be broken down further.

</details>

### 247. In FOPL, when we want to refer to an atom, or its negation we often use the word \_\_\_\_\_\_.

1. Lists
2. Terms
3. Atoms
4. Literals

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Literals

**Explanation:**

* In **First-Order Predicate Logic (FOPL)**, a **literal** is an atom or its negation.
* Literals are used to build more complex logical expressions.

</details>

### 248. Translate English to FOPL: Khusboo likes Pizza.

1. Likes (Khusboo, Pizza)
2. Likes (Pizza, Khusboo)
3. Khusboo (Pizza, likes)
4. Pizza (khusboo, likes)

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Likes (Khusboo, Pizza)

**Explanation:**

* The correct translation of "Khusboo likes Pizza" into FOPL is **Likes(Khusboo, Pizza)**.
* Here, "Likes" is the predicate, "Khusboo" is the subject, and "Pizza" is the object.

</details>

### 249. Translate English to FOPL: Khusboo owns iPhone\_14pro.

1. Owns (Khusboo, iPhone\_14pro)
2. Owns (iPhone\_14pro, Khusboo)
3. Khusboo (iPhone\_14pro, owns)
4. iPhone\_14pro (khusboo, owns)

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Owns (Khusboo, iPhone\_14pro)

**Explanation:**

* The correct translation of "Khusboo owns iPhone\_14pro" into FOPL is **Owns(Khusboo, iPhone\_14pro)**.
* Here, "Owns" is the predicate, "Khusboo" is the subject, and "iPhone\_14pro" is the object.

</details>

### 250. Translate English to FOPL: Charlie is Dog.

1. Charlie (Dog)
2. Dog (Charlie)
3. Charlie → Dog
4. Charlie ←→ Dog

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Dog (Charlie)

**Explanation:**

* The correct translation of "Charlie is Dog" into FOPL is **Dog(Charlie)**.
* Here, "Dog" is the predicate, and "Charlie" is the subject.

</details>

### 251. Translate English to FOPL: All kings are person.

1. "x: Kings(x) → Person(x).
2. "x: Kings(x) V Person(x).
3. "x: Kings(x) ←→ Person(x).
4. "x: Kings(x) ^Person(x).

<details>

<summary>Show me the answer</summary>

**Answer:** 1. "x: Kings(x) → Person(x).

**Explanation:**

* The correct translation of "All kings are person" into FOPL is **∀x: Kings(x) → Person(x)**.
* This means "for all x, if x is a king, then x is a person."

</details>

### 252. Translate English to FOPL: Nobody loves Harry\_Maguire

1. -Loves (x, Harry\_Maguire).
2. ILoves (x, Harry\_Maguire).
3. Loves (nobody, Harry\_Maguire).
4. -Loves (Harry\_Maguire).

<details>

<summary>Show me the answer</summary>

**Answer:** 1. -Loves (x, Harry\_Maguire).

**Explanation:**

* The correct translation of "Nobody loves Harry\_Maguire" into FOPL is **¬∃x: Loves(x, Harry\_Maguire)**.
* This means "there does not exist an x such that x loves Harry\_Maguire."

</details>

### 253. The primary difference between PL and FOPL is their ontological commitment (What exists in the world — TRUTH). Do you satisfy with the statement?

1. Do not Satisfy
2. Satisfy
3. Partially Satisfy
4. Rather not say

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Satisfy

**Explanation:**

* The primary difference between **Propositional Logic (PL)** and **First-Order Predicate Logic (FOPL)** is their ontological commitment.
* FOPL allows for more expressive statements about the existence of objects and their properties, while PL is limited to simple propositions.

</details>

### 254. Propositional logic is declarative. i.e., the pieces of syntax correspond to facts so FOPL was introduced.

1. Strongly True
2. Strongly False
3. May be True
4. May be False

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Strongly True

**Explanation:**

* **Propositional Logic (PL)** is declarative, meaning its syntax corresponds to facts.
* **First-Order Predicate Logic (FOPL)** was introduced to extend this expressiveness by allowing quantification and predicates.

</details>

### 255. \_\_\_\_\_\_ is the major families of first-order inference algorithms.

1. Forward chaining
2. Backward chaining
3. Resolution
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* The major families of first-order inference algorithms include **forward chaining**, **backward chaining**, and **resolution**.
* These algorithms are used to derive conclusions from logical statements in FOPL.

</details>

### 256. Bayes' theorem is also known as Bayes' rule, Bayes' law, or Bayesian reasoning, which determines the probability of an event with \_\_\_\_\_\_.

1. Unwanted knowledge
2. Uncertain knowledge

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Uncertain knowledge

**Explanation:**

* **Bayes' theorem** is used to update the probability of an event based on new information, even when the knowledge is uncertain.
* It is a fundamental concept in probability theory and statistics.

</details>

### 257. \_\_\_\_\_\_ is unavoidable in everyday reasoning and in many real-world domains.

1. Certainty in reasoning
2. Uncertainty in reasoning
3. Probability
4. Logic

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Uncertainty in reasoning

**Explanation:**

* **Uncertainty** is a common aspect of everyday reasoning and real-world domains.
* It arises due to incomplete or ambiguous information, making it a key challenge in AI and decision-making.

</details>

### 258. \_\_\_\_\_\_ is the main sources on uncertainty in reasoning.

1. Imprecise knowledge
2. Incomplete knowledge
3. Unreliable knowledge
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* The main sources of uncertainty in reasoning include **imprecise knowledge**, **incomplete knowledge**, and **unreliable knowledge**.
* These factors contribute to the complexity of decision-making in uncertain environments.

</details>

### 259. Representing a certain knowledge using Predicate logic (PL) and First order logic (FOL): Eg; "Patient Akshay has a cavity". Represent this English sentence in logic.

1. PL: Cavity FOL: Dental Disease (Akshay, Cavity)
2. PL: Akshay FOL: Dental Disease (Akshay, Cavity)
3. PL: Akshay ⇔ Cavity FOL: Dental Disease (Cavity, Akshay)
4. PL: Cavity,Akshay FOL: Dental Disease (Akshay, Cavity)

<details>

<summary>Show me the answer</summary>

**Answer:** 1. PL: Cavity FOL: Dental Disease (Akshay, Cavity)

**Explanation:**

* In **Propositional Logic (PL)**, the statement can be represented as **Cavity**.
* In **First-Order Logic (FOL)**, it can be represented as **Dental\_Disease(Akshay, Cavity)**, where "Dental\_Disease" is the predicate, "Akshay" is the subject, and "Cavity" is the object.

</details>

### 260. In \_\_\_\_\_\_ commitments: An agent believes a sentence to be true; false or has no opinion.

1. Ontological
2. Epistemological
3. Both A and B
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Epistemological

**Explanation:**

* **Epistemological commitments** refer to an agent's beliefs about the truth, falsity, or uncertainty of a sentence.
* This is related to the agent's knowledge and reasoning about the world.

</details>

### 261. In \_\_\_\_\_\_ commitments: Facts hold or do not hold in the world.

1. Ontological
2. Epistemological
3. Both A and B
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Ontological

**Explanation:**

* **Ontological commitments** refer to the existence of facts in the world, regardless of an agent's beliefs.
* This is related to the nature of reality and what exists in the world.

</details>

### 262. How many terms are required for building a bayes model?

1. 1 conditional probability and 2 unconditional probability
2. 2 conditional probability and 1 unconditional probability
3. 3 conditional probability and 0 unconditional probability
4. 0 conditional probability and 1 unconditional probability

<details>

<summary>Show me the answer</summary>

**Answer:** 1. 1 conditional probability and 2 unconditional probability

**Explanation:**

* Building a **Bayesian model** typically requires **1 conditional probability** (e.g., P(A|B)) and **2 unconditional probabilities** (e.g., P(A) and P(B)).
* These probabilities are used to calculate the posterior probability using Bayes' theorem.

</details>

### 263. During \_\_\_\_\_\_ the bayes rule can be implemented

1. Accessing queries
2. Increasing reliability
3. Decreasing reliability
4. Answering probabilistic query

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Answering probabilistic query

**Explanation:**

* **Bayes' rule** is implemented when answering **probabilistic queries**, such as calculating the probability of an event given new evidence.
* It is a key tool in probabilistic reasoning and decision-making.

</details>

### 264. Bayesian network provides \_\_\_\_\_\_.

1. Complete description of the domain
2. Few descriptions of the domain
3. Complete description of the problem
4. Few descriptions of the problem

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Complete description of the domain

**Explanation:**

* A **Bayesian network** provides a **complete description of the domain** by modeling the probabilistic relationships between variables.
* It is a graphical representation of the joint probability distribution of a set of variables.

</details>

### 265. By implementing \_\_\_\_\_\_ Bayesian network can be used to answer any user query.

1. Partial distribution
2. Joint distribution
3. Full distribution
4. Random Variable

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Joint distribution

**Explanation:**

* By implementing the **joint distribution**, a Bayesian network can be used to answer any user query about the probabilities of events.
* The joint distribution represents the probabilities of all possible combinations of variables in the network.

</details>

### 266. Belief network, decision network, Bayesian model are all known as \_\_\_\_\_\_

1. Non-bayesian belief network
2. Bayesian belief network
3. Bayesian non-belief network
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Bayesian belief network

**Explanation:**

* **Belief network**, **decision network**, and **Bayesian model** are all terms used to describe **Bayesian belief networks**.
* These networks are used to model probabilistic relationships between variables.

</details>

### 267. The Bayesian network graph does not contain any cyclic graph. So, it is known as a \_\_\_\_\_\_.

1. Direct Cyclic Graph
2. Direct Acyclic Graph
3. Cyclic Acyclic Graph
4. Significant Acyclic Graph

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Direct Acyclic Graph

**Explanation:**

* A **Bayesian network** is represented as a **Directed Acyclic Graph (DAG)**, meaning it has no cycles.
* This structure ensures that the network can be used for probabilistic inference without logical inconsistencies.

</details>

### 268. Bayesian Network has \_\_\_\_\_\_ variables.

1. Discrete
2. Asynchronous
3. Continuous
4. Both A and D

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both A and D

**Explanation:**

* A **Bayesian network** can have both **discrete** and **continuous** variables.
* This flexibility allows it to model a wide range of real-world scenarios.

</details>

### 269. A belief network is a graph in which the following holds \_\_\_\_\_\_.

1. A set of random variables
2. A set of directive links or arrows connects pairs of nodes.
3. The conditional probability table for each node
4. The graph has no directed cycles
5. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 5. All of above

**Explanation:**

* A **belief network** is a graph that includes a set of random variables, directed links between nodes, conditional probability tables, and no directed cycles.
* These properties define the structure and behavior of the network.

</details>

### 270. A Belief network with one node for each state and sensor variable for each time step is called a \_\_\_\_\_\_

1. Dynamic belief network
2. Static belief network
3. Serial belief network
4. Probability belief network

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Dynamic belief network

**Explanation:**

* A **dynamic belief network** is a type of Bayesian network that models temporal processes by including nodes for each state and sensor variable at each time step.
* It is used to model systems that evolve over time.

</details>

### 271. In \_\_\_\_\_\_ expertise is transferred from an expert to a computer and it is stored in computer.

1. User Interface
2. Expert System
3. Inference Engine
4. Natural Language Processing

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Expert System

**Explanation:**

* An **expert system** is a computer system that transfers expertise from a human expert to a computer, where it is stored and used to solve problems.
* It is a key application of AI in knowledge-based systems.

</details>

### 272. In \_\_\_\_\_\_ users can call on the computer for specific advice as needed for the user.

1. User Interface
2. Expert System
3. Inference Engine
4. Natural Language Processing

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Expert System

**Explanation:**

* An **expert system** allows users to request specific advice or solutions to problems based on the knowledge stored in the system.
* It is designed to mimic the decision-making ability of a human expert.

</details>

### 273. In \_\_\_\_\_\_ the computer can make inferences and arrive at the conclusion.

1. User Interface
2. Expert System
3. Inference Engine
4. Natural Language Processing

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Inference Engine

**Explanation:**

* The **inference engine** is the component of an expert system that performs logical reasoning and draws conclusions from the knowledge base.
* It is responsible for making inferences based on the rules and data provided.

</details>

### 274. In \_\_\_\_\_\_ the computer system advices the non-experts and explains, if necessary, the actual logic behind the advice which it has provided.

1. User Interface
2. Expert System
3. Inference Engine
4. Natural Language Processing

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Expert System

**Explanation:**

* An **expert system** provides advice to non-experts and can explain the reasoning behind its recommendations.
* This feature makes it a valuable tool for decision support and problem-solving.

</details>

### 275. Expert System can \_\_\_\_\_\_.

1. Display intelligent behavior
2. Draw conclusions from complex relationships
3. Provide portable knowledge
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* An **expert system** can display intelligent behavior, draw conclusions from complex relationships, and provide portable knowledge that can be used across different domains.
* These capabilities make it a powerful tool in AI.

</details>

### 276. \_\_\_\_\_\_ is one of the components of expert system.

1. Knowledge base and Inference Engine
2. User Interface and Explanation subsystem (facility)
3. Working Area
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* The components of an **expert system** include the **knowledge base**, **inference engine**, **user interface**, **explanation subsystem**, and **working area**.
* These components work together to provide expert-level advice and solutions.

</details>

### 277. The \_\_\_\_\_\_ is one of the components of an expert system which represents facts and rules.

1. Inference Engine
2. Knowledge Base
3. User Interface
4. Explanation Subsystem

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Knowledge Base

**Explanation:**

* The **knowledge base** is the component of an expert system that stores facts, rules, and other information used to solve problems.
* It is the repository of domain-specific knowledge.

</details>

### 278. The most basic function of the \_\_\_\_\_\_ is to acquire relevant data from the knowledge base, interpret it, and find a solution to the user’s problem.

1. User interface
2. Inference engine
3. Explanation Subsystem / module
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Inference engine

**Explanation:**

* The **inference engine** is responsible for acquiring data from the knowledge base, interpreting it, and deriving solutions to user problems.
* It is the core reasoning component of an expert system.

</details>

### 279. \_\_\_\_\_\_ is used to allow the expert systems to acquire more data from various sources and store it in the knowledge base.

1. User interface
2. Knowledge acquisition and learning module
3. Explanation Subsystem / module
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Knowledge acquisition and learning module

**Explanation:**

* The **knowledge acquisition and learning module** is responsible for acquiring new data and knowledge from various sources and updating the knowledge base.
* It ensures that the expert system remains up-to-date and accurate.

</details>

### 280. \_\_\_\_\_\_ is essential for a non-expert user to interact with the expert system and find solutions.

1. User interface
2. Knowledge acquisition and learning module
3. Explanation Subsystem / module
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. User interface

**Explanation:**

* The **user interface** is essential for non-expert users to interact with the expert system, input queries, and receive solutions.
* It provides a user-friendly way to access the system's capabilities.

</details>

### 281. \_\_\_\_\_\_ and \_\_\_\_\_\_ are 2 strategies used by inference engine in Expert system.

1. Forward gaining, backward gaining
2. Forward processing, backward processing
3. Forward chaining, backward chaining
4. Forward debugging, backward debugging

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Forward chaining, backward chaining

**Explanation:**

* The **inference engine** in an expert system uses **forward chaining** (data-driven reasoning) and **backward chaining** (goal-driven reasoning) to derive conclusions.
* These strategies are used to solve problems based on the available knowledge.

</details>

### 282. With \_\_\_\_\_\_ strategy, an expert system is able to answer the question, “What can happen next?”

1. Backward chaining
2. Forward chaining
3. Forward debugging
4. Backward debugging

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Forward chaining

**Explanation:**

* **Forward chaining** is a strategy where the expert system starts with known facts and applies rules to derive new conclusions.
* It is used to answer questions like "What can happen next?" by predicting future outcomes based on current data.

</details>

### 283. With \_\_\_\_\_\_ strategy, an expert system is able to answer the question, “Why did this happen?”

1. Backward chaining
2. Forward chaining
3. Forward debugging
4. Backward debugging

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Backward chaining

**Explanation:**

* **Backward chaining** is a strategy where the expert system starts with a goal and works backward to determine the conditions that led to it.
* It is used to answer questions like "Why did this happen?" by identifying the causes of observed outcomes.

</details>

### 284. Rule-based is the type of \_\_\_\_\_\_.

1. Computer System
2. Knowledge Base
3. Expert System
4. Inference Engine

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Expert System

**Explanation:**

* A **rule-based system** is a type of **expert system** that uses a set of rules to derive conclusions from known facts.
* It is a common approach in AI for implementing expert systems.

</details>

### 285. A \_\_\_\_\_\_ is nothing but expert system without knowledge base.

1. Tools
2. User Interface
3. Shell
4. Inference Engine

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Shell

**Explanation:**

* A **shell** is an expert system framework without a specific knowledge base.
* It provides the structure and tools for building expert systems but requires the addition of domain-specific knowledge.

</details>

### 286. What is the full form of JESS Expert System Technology?

1. Javascript Expert Sub System
2. Javascript Expert System Shell
3. Java Expert Sub System
4. Java Expert System Shell

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Java Expert System Shell

**Explanation:**

* **JESS** stands for **Java Expert System Shell**.
* It is a rule-based expert system shell written in Java, used for developing expert systems.

</details>

### 287. \_\_\_\_\_\_ means how a particular thing can be accomplished in AI.

1. Procedural knowledge
2. Declarative knowledge
3. Tacit Knowledge
4. Explicit Knowledge

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Procedural knowledge

**Explanation:**

* **Procedural knowledge** refers to the knowledge of how to perform specific tasks or procedures.
* It is about knowing the steps or methods to achieve a particular goal.

</details>

### 288. \_\_\_\_\_\_ means basic knowledge about something in AI.

1. Procedural knowledge
2. Declarative knowledge
3. Tacit Knowledge
4. Explicit Knowledge

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Declarative knowledge

**Explanation:**

* **Declarative knowledge** refers to the basic knowledge about facts, concepts, and relationships.
* It is about knowing "what" rather than "how."

</details>

### 289. \_\_\_\_\_\_ emphasize how to do something to solve a given problem.

1. Procedural knowledge
2. Declarative knowledge
3. Tacit Knowledge
4. Explicit Knowledge

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Procedural knowledge

**Explanation:**

* **Procedural knowledge** emphasizes the methods or steps required to solve a problem.
* It is focused on the "how" of problem-solving.

</details>

### 290. \_\_\_\_\_\_ emphasize what to do something to solve a given problem.

1. Procedural knowledge
2. Declarative knowledge
3. Tacit Knowledge
4. Explicit Knowledge

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Declarative knowledge

**Explanation:**

* **Declarative knowledge** emphasizes the facts and information needed to solve a problem.
* It is focused on the "what" of problem-solving.

</details>

### 291. \_\_\_\_\_\_ is the extraction of knowledge from sources of expertise, and transfer to the knowledge base.

1. Knowledge requisition
2. Knowledge acquisition
3. Knowledge processing
4. Knowledge debugging

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Knowledge acquisition

**Explanation:**

* **Knowledge acquisition** is the process of extracting knowledge from experts and transferring it to the knowledge base of an expert system.
* It is a critical step in building expert systems.

</details>

### 292. \_\_\_\_\_\_ may also include acquiring knowledge from other sources such as books, technical manuscript and drawings.

1. Knowledge requisition
2. Knowledge elicitation
3. Knowledge processing
4. Knowledge debugging

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Knowledge elicitation

**Explanation:**

* **Knowledge elicitation** involves acquiring knowledge from various sources, including books, technical manuscripts, and drawings.
* It is a broader process that complements knowledge acquisition.

</details>

### 293. Knowledge engineer performs important tasks

1. Identifying the problem domain.
2. Choosing the right expert.
3. Preparing for knowledge acquisition.
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* A **knowledge engineer** performs tasks such as identifying the problem domain, choosing the right expert, and preparing for knowledge acquisition.
* These tasks are essential for building effective expert systems.

</details>

### 294. During choosing the right expert for implementing on Expert System \_\_\_\_\_\_ should be one of the desirable characteristics of expert.

1. Knows when to follow heuristics and when to make exceptions.
2. Sees the big picture.
3. Possesses good communication skills.
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* The right expert for an expert system should possess characteristics such as knowing when to follow heuristics, seeing the big picture, and having good communication skills.
* These traits ensure that the expert can effectively contribute to the system's knowledge base.

</details>

### 295. \_\_\_\_\_\_ are the tasks performed in knowledge acquisition.

1. Collect and interpret
2. Analyze
3. Design
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* The tasks performed in **knowledge acquisition** include collecting and interpreting data, analyzing the information, and designing the knowledge base.
* These steps are crucial for building a robust expert system.

</details>

### 296. Introspection, Observation, Induction, Protocol Analysis, Prototyping and Interviewing are the techniques of \_\_\_\_\_\_.

1. Knowledge Processing
2. Knowledge elaboration
3. Knowledge acquisition
4. Knowledge debugging

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Knowledge acquisition

**Explanation:**

* Techniques such as **introspection**, **observation**, **induction**, **protocol analysis**, **prototyping**, and **interviewing** are used in **knowledge acquisition**.
* These methods help extract knowledge from experts and other sources.

</details>

### 297. \_\_\_\_\_\_ is the process of communicating with a computer in natural language via keyboard or voice.

1. Natural Language Processing
2. Natural Sentence Processing
3. Machine Learning
4. Computer Visioning

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Natural Language Processing

**Explanation:**

* **Natural Language Processing (NLP)** is the process of enabling computers to understand and interact with human language, whether through text or speech.
* It is a key area of AI research and application.

</details>

### 298. \_\_\_\_\_\_ refers to AI method of communicating with an intelligent system using a natural language such as English, Nepali, Hindi etc.

1. Natural Language Processing
2. Natural Sentence Processing
3. Machine Learning
4. Computer Visioning

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Natural Language Processing

**Explanation:**

* **Natural Language Processing (NLP)** refers to the AI methods used to enable communication between humans and intelligent systems using natural languages like English, Nepali, or Hindi.
* It is a critical component of human-computer interaction.

</details>

### 299. \_\_\_\_\_\_ is the main challenges of NLP.

1. Handling Ambiguity of Sentences
2. Handling Tokenization
3. Handling POS-Tagging
4. All of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the mentioned

**Explanation:**

* The main challenges of **Natural Language Processing (NLP)** include handling ambiguity in sentences, tokenization, and POS-tagging.
* These challenges arise due to the complexity and variability of human language.

</details>

### 300. These are the 2 components of natural language processing.

1. Natural language debugging and natural language compiling
2. Natural language publishing and natural language maintenance
3. Natural language organizing and natural language implementing
4. Natural language understanding and natural language generation

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Natural language understanding and natural language generation

**Explanation:**

* The two main components of **Natural Language Processing (NLP)** are **natural language understanding** (NLU) and **natural language generation** (NLG).
* NLU focuses on understanding human language, while NLG focuses on generating human-like language.

</details>

### 301. \_\_\_\_\_\_ is a subfield of natural language processing (NLP), which involves transforming human language into a machine-readable format.

1. Natural language debugging
2. Natural language compiling
3. Natural language understanding
4. Natural language generation

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Natural language understanding

**Explanation:**

* **Natural Language Understanding (NLU)** is a subfield of NLP that focuses on transforming human language into a format that machines can understand and process.
* It involves tasks like sentiment analysis, intent recognition, and entity extraction.

</details>

### 302. Automatic Ticket Routing, Machine Translation (MT), Automated Reasoning, Automatic Ticket Tagging & Reasoning, Question Answering etc. these are the examples of \_\_\_\_\_\_.

1. Natural language debugging
2. Natural language compiling
3. Natural language understanding (NLU)
4. Natural language generation

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Natural language understanding (NLU)

**Explanation:**

* Tasks like **Automatic Ticket Routing**, **Machine Translation**, and **Question Answering** are examples of **Natural Language Understanding (NLU)**.
* These tasks require the machine to understand and interpret human language.

</details>

### 303. \_\_\_\_\_\_ produces natural written or spoken language from structured and unstructured data.

1. Natural language debugging
2. Natural language compiling
3. Natural language understanding (NLU)
4. Natural language generation

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Natural language generation

**Explanation:**

* **Natural Language Generation (NLG)** is the process of producing natural written or spoken language from structured or unstructured data.
* It is used in applications like chatbots, report generation, and voice assistants.

</details>

### 304. \_\_\_\_\_\_ is used for generating the responses of chatbots and voice assistants such as Amazon's Alexa, Google's Assistant and Apple's Siri.

1. Natural language debugging
2. Natural language compiling
3. Natural language understanding (NLU)
4. Natural language generation

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Natural language generation

**Explanation:**

* **Natural Language Generation (NLG)** is used to generate responses for chatbots and voice assistants like Alexa, Google Assistant, and Siri.
* It converts structured data into human-like language.

</details>

### 305. Chatbots and "suggested text" features in email clients, such as Gmail's Smart Compose, are examples of applications that use both \_\_\_\_\_\_.

1. Natural language debugging and natural language compiling
2. Natural language publishing and natural language maintenance
3. Natural language organizing and natural language implementing
4. Natural language understanding and natural language generation

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Natural language understanding and natural language generation

**Explanation:**

* Chatbots and "suggested text" features use both **Natural Language Understanding (NLU)** to interpret user input and **Natural Language Generation (NLG)** to produce responses.
* These technologies work together to enable seamless human-machine interaction.

</details>

### 306. \_\_\_\_\_\_ are the NLG models and methodologies.

1. Long-Short term memory
2. Recurrent Neural Network
3. Markov chain
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* **Long-Short Term Memory (LSTM)**, **Recurrent Neural Networks (RNN)**, and **Markov chains** are all models and methodologies used in Natural Language Generation (NLG).
* These models help in generating coherent and contextually relevant text.

</details>

### 307. NLP is difficult because \_\_\_\_\_\_.

1. Imparting world knowledge is difficult.
2. Fictitious words
3. Poorly defined scopes
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* NLP is challenging because **imparting world knowledge** to machines is complex.
* **Fictitious words** and **poorly defined scopes** add to the difficulty in understanding and generating human language.

</details>

### 308. \_\_\_\_\_\_ is not the application of NLP.

1. Opening Computer Browser
2. Sentiment Analysis
3. Text Classification
4. Chat bots and Virtual Assistants

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Opening Computer Browser

**Explanation:**

* **Sentiment Analysis**, **Text Classification**, and **Chatbots** are all applications of NLP.
* **Opening a computer browser** is a system-level task and is not related to NLP.

</details>

### 309. \_\_\_\_\_\_ deals with How to design computers that can see (that is understand and interpret information in images/video).

1. Computer Application generation
2. Computer Vision
3. NLP
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Computer Vision

**Explanation:**

* **Computer Vision** is the field of AI that focuses on enabling computers to interpret and understand visual information from images or videos.
* It involves tasks like object detection, image recognition, and video analysis.

</details>

### 310. In. \_\_\_\_\_\_ by, applying machine learning models to images, computers can classify objects and respond like unlocking your smartphone when it recognizes your face.

1. Computer Application generation
2. Computer Vision
3. NLP
4. NLG

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Computer Vision

**Explanation:**

* **Computer Vision** uses machine learning models to classify objects in images.
* Applications like facial recognition for unlocking smartphones are examples of computer vision in action.

</details>

### 311. Consider the below image and answer the best solution. This figure is the complete process of \_\_\_\_\_\_.

Input Sensing device Interpreting device Output

1. Computer Application generation
2. Computer Vision
3. NLP
4. NLG

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Computer Vision

**Explanation:**

* The process described involves **input sensing**, **interpretation**, and **output**, which aligns with the workflow of **Computer Vision**.
* Computer Vision systems process visual data to produce meaningful outputs.

</details>

### 312. Two key technologies drive \_\_\_\_\_\_: a convolutional neural network and deep learning, a type of machine learning.

1. Computer Application generation
2. Computer Vision
3. NLP
4. NLG

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Computer Vision

**Explanation:**

* **Convolutional Neural Networks (CNNs)** and **Deep Learning** are key technologies that drive **Computer Vision**.
* These technologies enable computers to analyze and interpret visual data effectively.

</details>

### 313. A computer vision technique that relies on image templates is:

1. Edge detection
2. Binocular vision
3. Model-based vision
4. Robot vision

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Model-based vision

**Explanation:**

* **Model-based vision** is a computer vision technique that uses predefined templates or models to recognize objects in images.
* It compares the input image with stored templates to identify objects.

</details>

### 314. \_\_\_\_\_\_ is the use of devices for optical, non-contact sensing to receive and interpret an image of a real scene automatically, in order to obtain information and or control machines or processes.

1. Machine Vision / Computer Vision
2. Binocular vision
3. Model-based vision
4. Robot vision

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Machine Vision / Computer Vision

**Explanation:**

* **Machine Vision** or **Computer Vision** involves using optical devices to capture and interpret images for information extraction or process control.
* It is widely used in automation and robotics.

</details>

### 315. \_\_\_\_\_\_ is a programmable machine that imitates the actions or appearance of an intelligent human.

1. Robot
2. Pattern Recognition
3. Image Recognition
4. Agent

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Robot

**Explanation:**

* A **robot** is a programmable machine designed to imitate human actions or appearance.
* Robots are used in various applications, from manufacturing to healthcare.

</details>

### 316. To qualify as a \_\_\_\_, it should be able to do following works:

1. Get information from its surroundings
2. Physically move or manipulate objects
3. Robot
4. Machine
5. Image Recognizer
6. Agent

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Robot

**Explanation:**

* A **robot** must be able to gather information from its surroundings and physically interact with objects.
* These capabilities distinguish robots from other machines.

</details>

### 317. Following are the tasks that \_\_\_\_ can perform. Soldering wires to semiconductor chips, assembling cookies for Pepperidge, Painting cars at Ford plants, walking into live volcanoes, driving trains in Paris, flying to other planets to explore, Dive into deep water to recover things etc.

1. Robot
2. Machine
3. Image Recognizer
4. Agent

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Robot

**Explanation:**

* The tasks described, such as soldering, assembling, painting, and exploring, are performed by **robots**.
* Robots are versatile machines capable of performing a wide range of tasks.

</details>

### 318. \_\_\_\_\_\_ is the study of robots, autonomous embodied systems interacting with the physical world.

1. Dynamics
2. Physics
3. Robotics
4. Kinematics

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Robotics

**Explanation:**

* **Robotics** is the field of study that focuses on the design, construction, and operation of robots.
* It involves the interaction of robots with the physical world.

</details>

### 319. \_\_\_\_\_\_ is the Robot control approaches in AI

1. Reactive control
2. Pro-active control
3. Non-reactive control
4. Formal control

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Reactive control

**Explanation:**

* **Reactive control** is a robot control approach where the robot reacts to changes in its environment in real-time.
* This approach is commonly used in AI-driven robotics.

</details>

### 320. \_\_\_\_\_\_ has the ability to learn without being explicitly programmed.

1. Application Learning (AL)
2. Machine Learning (ML)
3. Neural Network (NN)
4. Computer Vision (CV)

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Machine Learning (ML)

**Explanation:**

* **Machine Learning (ML)** enables systems to learn from data and improve their performance without being explicitly programmed.
* It is a core component of AI.

</details>

### 321. ML is field of AI, consisting of learning algorithms that

1. Over time with experience
2. At executing some task
3. Improve their performance
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Machine Learning (ML)** involves algorithms that improve their performance over time with experience.
* These algorithms are designed to execute specific tasks and enhance their accuracy through learning.

</details>

### 322. \_\_\_\_\_\_ plays an important role in improving and understanding the efficiency of human learning.

1. Machine Learning
2. Artificial Intelligence
3. Convolutional Neural Network
4. Bayes Network

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Machine Learning

**Explanation:**

* **Machine Learning (ML)** helps in understanding and improving the efficiency of human learning by analyzing patterns in data.
* It provides insights into how humans learn and adapt.

</details>

### 323. \_\_\_\_\_\_ is one of the forms of machine learning.

1. Rote learning
2. Induction learning
3. Explanation based learning
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* **Rote learning**, **Induction learning**, and **Explanation-based learning** are all forms of machine learning.
* These methods represent different approaches to learning from data.

</details>

### 324. \_\_\_\_\_\_ is possible on the basis of memorization.

1. Rote learning
2. Induction learning
3. Explanation based learning
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Rote learning

**Explanation:**

* **Rote learning** is based on memorization, where information is repeated until it is learned.
* It does not involve understanding or reasoning.

</details>

### 325. In \_\_\_\_\_\_ process, a general rule is induced by the system from a set of observed instances.

1. Rote learning
2. Induction learning
3. Explanation based learning
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Induction learning

**Explanation:**

* **Induction learning** involves deriving general rules or patterns from specific observed instances.
* It is a key method in machine learning for generalization.

</details>

### 326. \_\_\_\_\_\_ deals with an idea of single-example learning.

1. Rote learning
2. Induction learning
3. Explanation based learning
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Explanation based learning

**Explanation:**

* **Explanation-based learning** focuses on learning from a single example by deriving a general rule or explanation.
* It is efficient for learning from limited data.

</details>

### 327. \_\_\_\_\_\_ learning is more data-intensive, data-driven while \_\_\_ learning is more knowledge-intensive, knowledge-driven.

1. Instance-based, Explanation based
2. Rote, Explanation
3. Explanation based, Instance-based
4. Explanation, Rote

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Instance-based, Explanation based

**Explanation:**

* **Instance-based learning** relies heavily on data and examples.
* **Explanation-based learning** relies on prior knowledge and reasoning.

</details>

### 328. learning algorithms are trained using labeled data.

1. Un-supervised
2. Reinforcement
3. Supervised
4. Semi-supervised

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Supervised

**Explanation:**

* **Supervised learning** algorithms are trained using labeled data, where the input-output pairs are provided.
* The model learns to map inputs to outputs based on the labeled examples.

</details>

### 329. learning algorithms are trained using unlabeled data.

1. Un-supervised
2. Reinforcement
3. Supervised
4. Semi-supervised

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Un-supervised

**Explanation:**

* **Unsupervised learning** algorithms are trained using unlabeled data.
* The model identifies patterns or structures in the data without explicit guidance.

</details>

### 330. learning model takes direct feedback to check if it is predicting correct output or not.

1. Un-supervised
2. Reinforcement
3. Supervised
4. Semi-supervised

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Supervised

**Explanation:**

* **Supervised learning** models receive direct feedback in the form of labeled data to check the correctness of their predictions.
* This feedback helps the model improve its accuracy.

</details>

### 331. learning model does not take any feedback.

1. Un-supervised
2. Reinforcement
3. Supervised
4. Semi-supervised

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Un-supervised

**Explanation:**

* **Unsupervised learning** models do not receive any feedback or labeled data.
* They rely on identifying patterns or clusters in the data without guidance.

</details>

### 332. While training the supervised model, data is usually split in the ratio of

1. 20:80
2. 80:20
3. 60:40
4. 40:60

<details>

<summary>Show me the answer</summary>

**Answer:** 2. 80:20

**Explanation:**

* In supervised learning, the data is typically split into an **80:20 ratio**, where 80% is used for training and 20% for testing.
* This split ensures that the model is trained on a sufficient amount of data while leaving enough for evaluation.

</details>

### 333. \_\_\_\_\_\_ are the two types of Supervised learning.

1. Classification and Regression
2. Clustering and Association
3. Classification and Association
4. Clustering and Regression

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Classification and Regression

**Explanation:**

* **Classification** and **Regression** are the two main types of supervised learning.
* Classification predicts discrete labels, while regression predicts continuous values.

</details>

### 334. \_\_\_\_\_\_ is a process of finding a function which helps in dividing the dataset into classes based on different parameters.

1. Classification
2. Regression
3. Clustering
4. Association

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Classification

**Explanation:**

* **Classification** is the process of dividing a dataset into classes based on specific parameters.
* It is used to predict discrete labels for data points.

</details>

### 335. \_\_\_\_\_\_ is a process of finding the correlations between dependent and independent variables.

1. Classification
2. Regression
3. Clustering
4. Association

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Regression

**Explanation:**

* **Regression** is used to find the relationship between dependent and independent variables.
* It predicts continuous values based on input features.

</details>

### 336. Consider the labelled dataset below. It is a dataset of a shopping store which is useful in predicting whether a customer will purchase a particular product under consideration or not based on his/her gender, age and salary.

| User ID  | Gender | Age | Salary | Purchased |
| -------- | ------ | --- | ------ | --------- |
| 15624510 | Male   | 19  | 19000  | 0         |
| 15810944 | Male   | 35  | 20000  | 1         |
| 15668575 | Female | 26  | 43000  | 0         |
| 15603246 | Female | 27  | 57000  | 0         |
| 15804002 | Male   | 19  | 76000  | 1         |
| 15728773 | Male   | 27  | 58000  | 1         |
| 15598044 | Female | 27  | 84000  | 0         |
| 15694829 | Female | 32  | 150000 | 1         |
| 15600575 | Male   | 25  | 33000  | 1         |
| 15727311 | Female | 35  | 65000  | 0         |
| 15570769 | Female | 26  | 80000  | 1         |
| 15606274 | Female | 26  | 52000  | 0         |
| 15746139 | Male   | 20  | 86000  | 1         |
| 15704987 | Male   | 32  | 18000  | 0         |
| 15628972 | Male   | 18  | 82000  | 0         |
| 15697686 | Male   | 29  | 80000  | 0         |
| 15733883 | Male   | 47  | 25000  | 1         |

Input: Gender, Age, Salary.\
Output: Purchased i.e., 0 or 1.\
Now look at the prediction data of “Purchased” column in given table and determine which model is this.

1. Regression
2. Classification
3. Association
4. Clustering

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Classification

**Explanation:**

* The output variable "Purchased" is binary (0 or 1), indicating a classification problem.
* The goal is to classify whether a customer will purchase the product or not.

</details>

### 337. Consider the labelled data set below. It is a Meteorological dataset which serves the purpose of predicting wind speed based on different parameters.

| Temperature | Pressure    | Relative Humidity | Wind Direction | Wind Speed  |
| ----------- | ----------- | ----------------- | -------------- | ----------- |
| 10.69261758 | 986.882019  | 54.1937313        | 195.7150879    | 3.278597116 |
| 13.59184184 | 987.8729248 | 48.0648859        | 189.2951202    | 2.909167767 |
| 17.70494885 | 988.1119385 | 39.11965597       | 192.9273834    | 2.973036289 |
| 20.95430404 | 987.8500366 | 30.66773218       | 202.0752869    | 2.965285993 |
| 22.92782774 | 987.2833862 | 26.06723423       | 210.6589203    | 2.798230886 |
| 24.04233986 | 986.2907104 | 23.46918024       | 221.1188507    | 2.627005816 |
| 24.41475295 | 985.2338867 | 22.25082295       | 233.7911987    | 2.448749781 |
| 23.93361956 | 984.8914795 | 22.35178837       | 244.3504333    | 2.454271793 |
| 22.68800023 | 984.8461304 | 23.7538641        | 253.0864716    | 2.418341875 |
| 20.56425776 | 984.8380737 | 27.07867944       | 264.5071106    | 2.318677425 |
| 17.76400389 | 985.4262085 | 33.54900114       | 280.7827454    | 2.343950987 |
| 11.25680746 | 988.9365597 | 53.74139903       | 68.15406036    | 1.650191426 |
| 14.37810685 | 989.6819458 | 40.70884681       | 72.62069702    | 1.553468896 |
| 18.45114201 | 990.2960205 | 30.85038484       | 71.70604706    | 1.005017161 |
| 22.54895853 | 989.9562988 | 22.81738811       | 44.66042709    | 0.284133832 |
| 24.23155922 | 988.796875  | 19.74790765       | 318.3214111    | 0.329656571 |

Input: Temperature, Pressure, Relative Humidity, Wind Direction.\
Output: Wind Speed.\
Now look at the prediction data of “Wind Speed” column in given table and determine which modes is this.

1. Regression
2. Classification
3. Association
4. Clustering

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Regression

**Explanation:**

* The output variable "Wind Speed" is continuous, indicating a regression problem.
* The goal is to predict the wind speed based on the input features.

</details>

### 338. \_\_\_\_\_\_ is a rule-based ML technique which finds out some very useful relations between parameters of a large data set.

1. Regression
2. Classification
3. Association
4. Clustering

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Association

**Explanation:**

* **Association** is a rule-based machine learning technique used to discover relationships between variables in large datasets.
* It is commonly used in market basket analysis.

</details>

### 339. \_\_\_\_\_\_ deals with “how can I group these set of items?”

1. Regression
2. Classification
3. Association
4. Clustering

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Clustering

**Explanation:**

* **Clustering** is used to group similar items together based on their characteristics.
* It is an unsupervised learning technique that identifies patterns in data.

</details>

### 340. In \_\_\_\_\_\_, model keeps on increasing its performance using a Reward Feedback to learn the behavior or pattern

1. Un-supervised learning
2. Supervised learning
3. Reinforcement learning
4. Clustering

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Reinforcement learning

**Explanation:**

* **Reinforcement learning** involves an agent that learns by receiving rewards or penalties for its actions.
* The model improves its performance based on the feedback it receives.

</details>

### 341. \_\_\_\_\_\_ is a machine learning training method based on rewarding desired behaviors and/or punishing undesired ones.

1. Un-supervised learning
2. Supervised learning
3. Reinforcement learning
4. Clustering

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Reinforcement learning

**Explanation:**

* **Reinforcement learning** uses a reward-punishment mechanism to train models.
* The agent learns to maximize rewards and minimize penalties.

</details>

### 342. Consider an example, how a Robotic dog learns the movement of his arms is an example of \_\_\_\_\_\_.

1. Un-supervised learning
2. Supervised learning
3. Reinforcement learning
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Reinforcement learning

**Explanation:**

* A robotic dog learning the movement of its arms through trial and error, receiving rewards for correct movements, is an example of **reinforcement learning**.
* The robot improves its performance based on feedback.

</details>

### 343. Decision tree builds classification or regression models in the form of a \_\_\_\_\_\_.

1. Root structure
2. Forest structure
3. Tree structure
4. Node structure

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Tree structure

**Explanation:**

* A **decision tree** builds models in the form of a tree structure, with nodes representing decisions and branches representing outcomes.
* It is used for both classification and regression tasks.

</details>

### 344. \_\_\_\_\_\_ is one of the types of decision tree.

1. Categorical variable decision tree
2. Continuous variable decision tree
3. Static variable decision tree
4. Both A and B

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both A and B

**Explanation:**

* Decision trees can handle both **categorical** and **continuous** variables.
* They are versatile models that can be used for various types of data.

</details>

### 345. A \_\_\_\_\_\_ is a decision support tool that uses a tree like graph of decisions and their possible consequences, including chance event outcomes, resource costs, and utility.

1. Maps
2. Graphs
3. Decision tree
4. Artificial NN

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Decision tree

**Explanation:**

* A **decision tree** is a graphical representation of decisions and their possible consequences.
* It is used for decision-making and predictive modeling.

</details>

### 346. \_\_\_\_\_\_ are the decision tree nodes.

1. End node
2. Decision node
3. Chance node
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* Decision trees consist of **decision nodes**, **chance nodes**, and **end nodes**.
* These nodes represent different stages in the decision-making process.

</details>

### 347. \_\_\_\_\_\_ symbol is used to represent decision node in decision tree.

1. Circles
2. Squares
3. Triangle
4. Rectangles

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Squares

**Explanation:**

* In decision trees, **squares** are used to represent decision nodes.
* These nodes indicate points where a decision must be made.

</details>

### 348. \_\_\_\_\_\_ symbol is used to represent chance node in decision tree.

1. Circles
2. Squares
3. Triangle
4. Rectangles

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Circles

**Explanation:**

* In decision trees, **circles** are used to represent chance nodes.
* These nodes indicate points where outcomes are uncertain.

</details>

### 349. \_\_\_\_\_\_ symbol is used to represent end nodes in decision tree.

1. Circles
2. Squares
3. Triangle
4. Rectangles

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Triangle

**Explanation:**

* In decision trees, **triangles** are used to represent end nodes.
* These nodes indicate the final outcome or result of a decision path.

</details>

### 350. \_\_\_\_\_\_ Simply calculates probability of each hypothesis, given data, and makes predictions based on this.

1. Hebbian learning
2. Bayesian learning
3. Neural learning
4. Supervised learning

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Bayesian learning

**Explanation:**

* **Bayesian learning** involves calculating the probability of each hypothesis given the data and making predictions based on these probabilities.
* It is a probabilistic approach to machine learning.

</details>

### 351. \_\_\_\_\_\_ is Artificial Intelligence is a set of tools for machine learning that uses statistics and functional analysis.

1. Hebbian learning
2. Bayesian learning
3. Statistical learning
4. Supervised learning

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Statistical learning

**Explanation:**

* **Statistical learning** is a set of tools in AI that uses statistical methods and functional analysis to analyze and interpret data.
* It is widely used in machine learning for predictive modeling and data analysis.

</details>

### 352. Fuzzy logic is a form of \_\_\_\_\_\_.

1. Binary valued logic
2. Many valued logic
3. Two valued logic
4. No value logic

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Many valued logic

**Explanation:**

* **Fuzzy logic** is a form of many-valued logic that allows for intermediate values between true and false.
* It is used to handle uncertainty and imprecision in decision-making.

</details>

### 353. Fuzzy logic can be implemented in \_\_\_\_\_\_.

1. Software
2. Hardware
3. Network
4. Both A and B

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both A and B

**Explanation:**

* **Fuzzy logic** can be implemented in both **software** and **hardware**.
* It is used in various applications, including control systems and decision-making processes.

</details>

### 354. Fuzzy logic can produce \_\_\_\_\_\_ output.

1. Only 1
2. 2
3. 3
4. 4

<details>

<summary>Show me the answer</summary>

**Answer:** 2. 2

**Explanation:**

* **Fuzzy logic** can produce **two outputs**: one for the degree of truth and another for the degree of falsity.
* This allows for more nuanced decision-making compared to binary logic.

</details>

### 355. \_\_\_\_\_\_ are the methods of Fuzzy interface system.

1. Mamdani Fuzzy Inference System
2. Takagi-Sugeno Fuzzy Model (TS Method)
3. Ricart-Aagrawala Model
4. Both A and B

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both A and B

**Explanation:**

* **Mamdani Fuzzy Inference System** and **Takagi-Sugeno Fuzzy Model** are two common methods used in fuzzy logic systems.
* These methods are used to model complex systems with uncertainty.

</details>

### 356. The truth values of traditional set theory is \_\_\_\_\_\_ and that of fuzzy set is \_\_\_\_\_\_.

1. Either 0 or 1, between 0 & 1
2. Between 0 & 1, only 1
3. Between 0 & 1, only 0
4. Either 0 or 1, either 0 or 1

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Either 0 or 1, between 0 & 1

**Explanation:**

* In **traditional set theory**, truth values are binary (either 0 or 1).
* In **fuzzy set theory**, truth values can be any value between 0 and 1, representing degrees of truth.

</details>

### 357. The store temperature is cold. Here the cold (use of linguistic variable is used) can be represented by \_\_\_\_\_\_.

1. Fuzzy Set
2. Crisp Set
3. Fuzzy & Crisp Set
4. Variable Set

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Fuzzy Set

**Explanation:**

* The term "cold" is a linguistic variable that can be represented using a **fuzzy set**.
* Fuzzy sets allow for the representation of imprecise or vague concepts like "cold."

</details>

### 358. Fuzzy Set theory defines fuzzy operators. Choose the fuzzy operators from the following.

1. OR
2. NOT
3. AND
4. All of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the mentioned

**Explanation:**

* **Fuzzy set theory** defines operators like **OR**, **NOT**, and **AND** to handle fuzzy logic operations.
* These operators are used to combine and manipulate fuzzy sets.

</details>

### 359. Fuzzy logic is usually represented as \_\_\_\_\_\_.

1. IF-THEN-ELSE rules
2. IF-ELSE-IF rules
3. IF-THEN rules
4. Both IF-THEN-ELSE rules & IF-THEN rules

<details>

<summary>Show me the answer</summary>

**Answer:** 3. IF-THEN rules

**Explanation:**

* **Fuzzy logic** is typically represented using **IF-THEN rules**.
* These rules define the relationship between input and output variables in a fuzzy system.

</details>

### 360. A \_\_\_\_\_\_ is a search heuristic that is inspired by Charles Darwin’s theory of natural evolution.

1. Generation Algorithm
2. Genetic Algorithm
3. Search Algorithm
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Genetic Algorithm

**Explanation:**

* A **genetic algorithm** is a search heuristic inspired by the process of natural selection and evolution.
* It is used to solve optimization problems by mimicking biological evolution.

</details>

### 361. \_\_\_\_\_\_ involves five phases to solve the complex optimization problems.

1. Generation Algorithm
2. Genetic Algorithm
3. Search Algorithm
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Genetic Algorithm

**Explanation:**

* The **genetic algorithm** involves five phases: initialization, selection, crossover, mutation, and termination.
* These phases are used to evolve solutions to complex optimization problems.

</details>

### 362. Fitness function is used to determine how \_\_\_\_\_\_ an individual is?

1. Fit
2. Weak
3. Tired
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Fit

**Explanation:**

* The **fitness function** in a genetic algorithm is used to evaluate how well an individual (solution) performs.
* It determines the fitness or quality of the individual in the context of the problem.

</details>

### 363. This is one of the types of Selection methods available is \_\_\_\_\_\_.

1. Roulette wheel selection
2. Tournament selection
3. Rank-based selection
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Roulette wheel selection**, **tournament selection**, and **rank-based selection** are all methods used in genetic algorithms to select individuals for reproduction.
* These methods help in choosing the fittest individuals for the next generation.

</details>

### 364. The operators involved in the reproduction phase are \_\_\_\_\_\_.

1. Mutation
2. Crossover
3. Genes
4. Both A and B

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both A and B

**Explanation:**

* The **reproduction phase** in genetic algorithms involves **mutation** and **crossover** operators.
* These operators are used to create new offspring from the selected individuals.

</details>

### 365. After the selection process; the creation of a child occurs in the \_\_\_\_\_\_ step.

1. Fitness Assignment
2. Reproduction
3. Termination
4. Initialization

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Reproduction

**Explanation:**

* After the selection process, the **reproduction** step involves creating new offspring (children) through crossover and mutation.
* This step is crucial for generating the next generation of solutions.

</details>

### 366. Types of Crossover styles are \_\_\_\_\_\_.

1. One point crossover and Two-point crossover
2. Livery crossover
3. Inheritable Algorithms crossover
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* **One-point crossover**, **two-point crossover**, and other crossover styles are used in genetic algorithms to combine genetic material from parents.
* These methods help in generating diverse offspring.

</details>

### 367. The \_\_\_\_\_\_ operator inserts random genes in the offspring (new child) to maintain the diversity in the population which can be done by flipping some bits in the chromosomes.

1. Mutation
2. Crossover
3. Genes
4. Allele

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Mutation

**Explanation:**

* The **mutation** operator introduces random changes in the offspring's genes to maintain genetic diversity.
* This helps in exploring new solutions and avoiding premature convergence.

</details>

### 368. \_\_\_\_\_\_ is one of the types of mutation styles.

1. Flip bit mutation
2. Gaussian mutation
3. Exchange/Swap mutation
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* **Flip bit mutation**, **Gaussian mutation**, and **exchange/swap mutation** are all types of mutation styles used in genetic algorithms.
* These methods introduce variability in the population.

</details>

### 369. \_\_\_\_\_\_ is a type of neural network which is based on a Feed-Forward strategy.

1. Artificial NN
2. Biological NN
3. Convolutional NN
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Artificial NN

**Explanation:**

* **Artificial Neural Networks (ANN)** are based on a feed-forward strategy, where information flows in one direction from input to output.
* They are widely used in machine learning for tasks like classification and regression.

</details>

### 370. \_\_\_\_\_\_ is a structure that consists of Synapse, dendrites, cell body, and axon.

1. Artificial NN
2. Biological NN
3. Convolutional NN
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Biological NN

**Explanation:**

* **Biological Neural Networks (BNN)** consist of structures like synapses, dendrites, cell bodies, and axons.
* These components are part of the human nervous system and are mimicked in artificial neural networks.

</details>

### 371. Artificial Neural Network (ANN) is \_\_\_\_\_\_.

1. Sequential and centralized
2. Non sequential and de-centralized
3. Parallel and distributed
4. Parallel and non-distributed

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Parallel and distributed

**Explanation:**

* **Artificial Neural Networks (ANN)** are **parallel and distributed** systems, meaning they process information simultaneously across multiple nodes.
* This structure allows for efficient learning and computation.

</details>

### 372. Biological Neural Network (BNN) is \_\_\_\_\_\_

1. Sequential and centralized
2. Non sequential and de-centralized
3. Parallel and distributed
4. Parallel and non-distributed

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Parallel and distributed

**Explanation:**

* **Biological Neural Networks (BNN)** are **parallel and distributed**, meaning they process information simultaneously across multiple neurons.
* This structure allows for efficient information processing in the brain.

</details>

### 373. Which NN is this?

\[x\_1 \quad x\_2 \quad x\_3 \quad \cdots \quad x\_n \in {0, 1}]

\[\begin{array}{c} \text{if} \ f \rightarrow y \in {0, 1} \end{array}]

1. McCulloch-pitts neuron
2. Minsky and Papert neuron
3. Both A and B
4. None of Above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. McCulloch-pitts neuron

**Explanation:**

* The diagram represents a **McCulloch-Pitts neuron**, which is a simple model of a biological neuron.
* It takes binary inputs and produces a binary output based on a threshold function.

</details>

### 374. The McCulloch-Pitts neural model, which was the earliest ANN model, has only two types of inputs \_\_\_\_\_\_

1. Extraordinary and inhabitation
2. Excitatory and Inhibitory
3. Extraordinary and Inhibitory
4. Excitatory and Inhabitation

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Excitatory and Inhibitory

**Explanation:**

* The **McCulloch-Pitts neuron** has two types of inputs: **excitatory** (which increase the neuron's activation) and **inhibitory** (which decrease the neuron's activation).
* These inputs determine whether the neuron fires or not.

</details>

### 375. The excitatory inputs have weights of \_\_\_\_\_\_ magnitude and the inhibitory weights have weights of \_\_\_\_\_\_ magnitude.

1. Positive, Negative
2. Negative, Negative
3. Negative, Negative
4. Positive, Positive

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Positive, Negative

**Explanation:**

* In the **McCulloch-Pitts neuron**, **excitatory inputs** have positive weights, while **inhibitory inputs** have negative weights.
* This determines the effect of each input on the neuron's activation.

</details>

### 376. The inputs of the McCulloch-Pitts neuron could be either \_\_\_\_\_\_ or \_\_\_\_\_\_

1. 0 or -1
2. 0 or 1
3. 0 or infinity
4. 0 or 2

<details>

<summary>Show me the answer</summary>

**Answer:** 2. 0 or 1

**Explanation:**

* The inputs to a **McCulloch-Pitts neuron** are binary, meaning they can only be **0 or 1**.
* This simplicity makes the model easy to analyze and understand.

</details>

### 377. Artificial Neural system are called \_\_\_\_\_\_

1. Neural networks and neurocomputers
2. Parallel distributed processors
3. Connectionists system
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* **Artificial Neural Systems** are referred to as **neural networks**, **neurocomputers**, **parallel distributed processors**, and **connectionist systems**.
* These terms highlight different aspects of how neural networks function.

</details>

### 378. An artificial neuron is designed to mimic the first-order characteristics of a \_\_\_\_\_\_

1. Physiological neuron
2. Geological neuron
3. Biological neuron
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Biological neuron

**Explanation:**

* An **artificial neuron** is designed to mimic the behavior of a **biological neuron**, which is the basic unit of the nervous system.
* It captures the first-order characteristics of how biological neurons process information.

</details>

### 379. Processing of ANN depends upon \_\_\_\_\_\_

1. Network Topology
2. Adjustments of Weights or Learning
3. Activation Functions
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* The processing of an **Artificial Neural Network (ANN)** depends on **network topology**, **weight adjustments**, and **activation functions**.
* These factors determine how the network learns and processes information.

</details>

### 380. A network topology in neural network is the arrangement of a network along with its \_\_\_\_\_\_

1. Nodes and connecting lines
2. Lines and curves
3. Graphs and vectors
4. Symbols and functions

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Nodes and connecting lines

**Explanation:**

* **Network topology** in neural networks refers to the arrangement of **nodes** (neurons) and **connecting lines** (synapses).
* This structure defines how information flows through the network.

</details>

### 381. According to the topology, ANN can be classified as \_\_\_\_\_\_

1. Feed forward Network
2. Feed backward Network
3. Both Feed forward and Backward Network
4. None

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Both Feed forward and Backward Network

**Explanation:**

* **Artificial Neural Networks (ANN)** can be classified as **feedforward networks** (information flows in one direction) and **feedback networks** (information flows in loops).
* Both types are used in different applications.

</details>

### 382. \_\_\_\_\_\_ is a non-recurrent network having processing units/nodes in layers and all the nodes in a layer are connected with the nodes of the previous layers.

1. Feed forward Network
2. Feed backward Network
3. Both Feed forward and Backward Network
4. None

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Feed forward Network

**Explanation:**

* A **feedforward network** is a non-recurrent network where nodes are organized in layers, and each layer is connected to the previous one.
* Information flows in one direction, from input to output.

</details>

### 383. Feed-forward network can be divided into \_\_\_\_\_\_

1. Single-layer feed forward
2. Multi-layer feed forward
3. No-layer feed forward
4. Both A and B

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both A and B

**Explanation:**

* **Feedforward networks** can be divided into **single-layer** and **multi-layer** networks.
* Single-layer networks have one layer of nodes, while multi-layer networks have multiple layers.

</details>

### 384. The concept is of \_\_\_\_\_\_ ANN having only one weighted layer.

1. Single-layer feed forward
2. Multi-layer feed forward
3. No-layer feed forward
4. Both A and B

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Single-layer feed forward

**Explanation:**

* A **single-layer feedforward network** has only one weighted layer of nodes.
* This type of network is simpler but less powerful than multi-layer networks.

</details>

### 385. Identify which Neural Network Topology is this?

* Inputs
* Outputs

1. Single-layer feed forward
2. Multi-layer feed forward
3. No-layer feed forward
4. None

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Single-layer feed forward

**Explanation:**

* The described topology has only **inputs** and **outputs**, indicating a **single-layer feedforward network**.
* This is the simplest form of a neural network.

</details>

### 386. The concept is of \_\_\_\_\_\_ ANN having more than one weighted layer.

1. Single-layer feed forward
2. Multi-layer feed forward
3. No-layer feed forward
4. None

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Multi-layer feed forward

**Explanation:**

* A **multi-layer feedforward network** has more than one weighted layer of nodes.
* These networks are more powerful and capable of learning complex patterns.

</details>

### 387. Identify which Neural network topology is this?

* Inputs
* Hidden
* Outputs

1. Single-layer feed forward
2. Multi-layer feed forward
3. No-layer feed forward
4. None

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Multi-layer feed forward

**Explanation:**

* The described topology includes **inputs**, **hidden layers**, and **outputs**, indicating a **multi-layer feedforward network**.
* Hidden layers allow the network to learn more complex relationships.

</details>

### 388. \_\_\_\_\_\_ network has feedback paths, which means the signal can flow in both directions using loops.

1. Feed forward Network
2. Feedback/Feed backward Network
3. Both Feed forward and Backward Network
4. None

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Feedback/Feed backward Network

**Explanation:**

* A **feedback/feed backward network** has loops that allow signals to flow in both directions.
* This type of network is used in applications like recurrent neural networks (RNNs).

</details>

### 389. Feedback/ Feed backward network can be divided into \_\_\_\_\_\_

1. Recurrent Network
2. Fully recurrent Network
3. Jordan Network
4. None

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Recurrent Network

**Explanation:**

* **Feedback/feed backward networks** can be divided into **recurrent networks**, where connections form cycles.
* These networks are used for tasks involving sequential data, such as time series prediction.

</details>

### 390. Identify which Neural network topology is this?

* Input layer
* Hidden layer
* Output layer

1. Feed-forward
2. Feedback
3. Linear
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Feedback

**Explanation:**

* The described topology includes **input**, **hidden**, and **output layers**, with feedback loops, indicating a **feedback network**.
* Feedback networks are used in applications like recurrent neural networks (RNNs).

</details>

### 391. \_\_\_\_\_\_ neural network architecture because all nodes are connected to all other nodes and each node works as both input and output.

1. Fully recurrent
2. Jordan
3. McClutch
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Fully recurrent

**Explanation:**

* In a **fully recurrent network**, all nodes are connected to all other nodes, and each node can act as both input and output.
* This architecture is used in complex tasks like sequence modeling.

</details>

### 392. Identify which Neural network topology is this?

* Input layer
* Hidden layer
* Output layer

1. Jordan
2. McClutch
3. Fully recurrent
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Fully recurrent

**Explanation:**

* The described topology includes **input**, **hidden**, and **output layers**, with all nodes connected to each other, indicating a **fully recurrent network**.
* This architecture is used in tasks requiring memory and sequential processing.

</details>

### 393. Identify which Neural network topology is this?

1. Jordan
2. McClutch
3. Fully recurrent
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Jordan

**Explanation:**

* The described topology is a **Jordan network**, which is a type of recurrent neural network with feedback connections from the output layer to the hidden layer.
* It is used in tasks involving sequential data.

</details>

### 394. \_\_\_\_\_\_ is defined as the extra force or effort applied over the input to obtain an exact output.

1. Deactivation function
2. Activation function
3. Parallel function
4. Distributed function

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Activation function

**Explanation:**

* The **activation function** in a neural network determines the output of a neuron based on its input.
* It introduces non-linearity, allowing the network to learn complex patterns.

</details>

### 395. Non-linear activation function can be divided on the basis of their \_\_\_\_\_\_.

1. Signs and ranges
2. Range and curves
3. Range and symbols
4. Symbols and curves

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Range and curves

**Explanation:**

* **Non-linear activation functions** are categorized based on their **range** (output values) and **curves** (shape of the function).
* Examples include sigmoid, tanh, and ReLU functions.

</details>

### 396. The main reason why we use sigmoid function is because it exists between \_\_\_\_\_\_.

1. 0 to 2
2. -1 to 1
3. -1 to 0
4. 0 to 1

<details>

<summary>Show me the answer</summary>

**Answer:** 4. 0 to 1

**Explanation:**

* The **sigmoid function** outputs values between **0 and 1**, making it useful for binary classification tasks.
* It is also differentiable, which is important for backpropagation in neural networks.

</details>

### 397. The range of the tanh function is from \_\_\_\_\_\_.

1. 0 to 2
2. -1 to 1
3. -1 to 0
4. 0 to 1

<details>

<summary>Show me the answer</summary>

**Answer:** 2. -1 to 1

**Explanation:**

* The **tanh function** outputs values between **-1 and 1**, making it useful for tasks where the output needs to be centered around zero.
* It is also differentiable, like the sigmoid function.

</details>

### 398. The range of the Re-Lu function is from \_\_\_\_\_\_.

1. 0 to infinity
2. -1 to 1
3. Infinity to 0
4. 0 to 1

<details>

<summary>Show me the answer</summary>

**Answer:** 1. 0 to infinity

**Explanation:**

* The **ReLU (Rectified Linear Unit)** function outputs values from **0 to infinity**, making it computationally efficient and widely used in deep learning.
* It helps mitigate the vanishing gradient problem.

</details>

### 399. The range of the Leaky Re-Lu function is from \_\_\_\_\_\_.

1. 0 to infinity
2. -1 to 1
3. -infinity to infinity
4. 0 to 1

<details>

<summary>Show me the answer</summary>

**Answer:** 3. -infinity to infinity

**Explanation:**

* The **Leaky ReLU** function outputs values from **-infinity to infinity**, allowing for small negative outputs when the input is negative.
* This helps address the "dying ReLU" problem.

</details>

### 400. The Neural Network architecture is made of individual units called \_\_\_\_\_\_ that mimic the biological behavior of the brain.

1. Nerves
2. Neurons
3. Genes
4. Chromosomes

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Neurons

**Explanation:**

* The basic units of a **Neural Network** are called **neurons**, which mimic the behavior of biological neurons in the brain.
* These neurons are connected in layers to form the network.

</details>

### 401. \_\_\_\_\_\_ is a possible mechanism for synaptic modification in the brain.

1. Hebbian Rule
2. McCulloch pits neuron
3. Hopfield network
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Hebbian Rule

**Explanation:**

* The **Hebbian Rule** is a theory that explains how neurons adapt and strengthen their connections based on activity.
* It is often summarized as "cells that fire together, wire together."

</details>

### 402. The \_\_\_\_\_\_ can be used to train neural networks for pattern recognition.

1. Hebbian Rule
2. McCulloch pits neuron
3. Hopfield network
4. Genetic Algorithm

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Hebbian Rule

**Explanation:**

* The **Hebbian Rule** is used in training neural networks, particularly for tasks like pattern recognition.
* It helps in strengthening the connections between neurons that are frequently activated together.

</details>

### 403. If two neurons on either side of a synapse are activated simultaneously, the strength of the synapse will increase is \_\_\_\_\_\_.

1. Hebbian Learning Rule
2. Perceptron Learning Rule
3. Delta Learning Rule
4. Genetic Algorithm Learning Rule

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Hebbian Learning Rule

**Explanation:**

* The **Hebbian Learning Rule** states that if two neurons are activated simultaneously, the synaptic connection between them strengthens.
* This is the basis of learning in neural networks.

</details>

### 404. \_\_\_\_\_\_ is the one of the Neural Network Learning rules.

1. Hebbian Learning Rule
2. Perceptron Learning Rule
3. Delta Learning Rule
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* **Hebbian Learning Rule**, **Perceptron Learning Rule**, and **Delta Learning Rule** are all learning rules used in neural networks.
* Each rule has its own mechanism for updating weights and improving the network's performance.

</details>

### 405. \_\_\_\_\_\_ is an error correcting the supervised learning algorithm of single layer feedforward networks with linear activation function.

1. Hebbian Learning Rule
2. Perceptron Learning Rule
3. Delta Learning Rule
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Perceptron Learning Rule

**Explanation:**

* The **Perceptron Learning Rule** is used in single-layer feedforward networks with linear activation functions.
* It corrects errors by adjusting weights based on the difference between the predicted and actual outputs.

</details>

### 406. \_\_\_\_\_\_ also called Least Mean Square (LMS)

1. Hebbian Learning Rule
2. Perceptron Learning Rule
3. Delta Learning Rule
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Delta Learning Rule

**Explanation:**

* The **Delta Learning Rule** is also known as the **Least Mean Square (LMS)** algorithm.
* It minimizes the error by adjusting weights based on the gradient of the error function.

</details>

### 407. A \_\_\_\_\_\_ is an algorithm for supervised learning of binary classifiers. This algorithm enables neurons to learn and processes elements in the training set one at a time.

1. Hebbian Learning
2. Delta Learning
3. Perceptron
4. Delta Learning

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Perceptron

**Explanation:**

* The **Perceptron** is a supervised learning algorithm used for binary classification.
* It processes training examples one at a time and updates weights to minimize errors.

</details>

### 408. \_\_\_\_\_\_ are one of the types of perceptron.

1. Single layer perceptron
2. Multilayer perceptron
3. No layer perceptron
4. Both A and B

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both A and B

**Explanation:**

* **Single-layer perceptron** and **multilayer perceptron** are two types of perceptrons.
* Single-layer perceptrons are simpler, while multilayer perceptrons can model more complex relationships.

</details>

### 409. \_\_\_\_\_\_ can learn only linearly separable patterns.

1. Single layer perceptron
2. Multilayer perceptron
3. No layer perceptron
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Single layer perceptron

**Explanation:**

* A **single-layer perceptron** can only learn patterns that are linearly separable.
* It cannot handle complex, non-linear relationships.

</details>

### 410. \_\_\_\_\_\_ can learn about two or more layers having a greater processing power.

1. Single layer perceptron
2. Multilayer perceptron
3. No layer perceptron
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Multilayer perceptron

**Explanation:**

* A **multilayer perceptron** has multiple layers of neurons, allowing it to learn complex, non-linear patterns.
* It has greater processing power compared to single-layer perceptrons.

</details>

### 411. The given figure is of \_\_\_\_\_\_.

\[\begin{array}{c} \text{Xi} \ \text{X2} \ \text{Xn} \end{array}]

Input Sum

Activation Function

1. Single layer perceptron
2. Multilayer perceptron
3. No layer perceptron
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Single layer perceptron

**Explanation:**

* The figure represents a **single-layer perceptron**, which consists of input nodes, a summation function, and an activation function.
* It is the simplest form of a neural network.

</details>

### 412. The given figure is of \_\_\_\_\_\_.

Input layer Hidden layers Output layer

1. Single layer perceptron
2. Multilayer perceptron
3. No layer perceptron
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Multilayer perceptron

**Explanation:**

* The figure represents a **multilayer perceptron**, which includes an input layer, one or more hidden layers, and an output layer.
* It is capable of learning complex patterns.

</details>

### 413. Identify the type of perceptron activation function.

$$y = \frac{1}{1 + e^{-x}}$$\
$$y = \frac{e^{x} - e^{-x}}{e^{x} + e^{-x}}$$

1. Sigmoid and tanh
2. Tanh and sigmoid
3. Linear, Relu
4. Relu, Linear

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Sigmoid and tanh

**Explanation:**

* The functions shown are the **sigmoid** and **tanh** activation functions.
* Sigmoid outputs values between 0 and 1, while tanh outputs values between -1 and 1.

</details>

### 414. Identify the type of perceptron activation function.

$$y = \max(0, x)$$\
$$y = \max(\alpha x, x)$$

1. Sigmoid and tanh
2. Tanh and sigmoid
3. Leaky Relu and Relu
4. Relu and, Leaky Relu

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Relu and, Leaky Relu

**Explanation:**

* The functions shown are the **ReLU (Rectified Linear Unit)** and **Leaky ReLU** activation functions.
* ReLU outputs the input directly if it is positive, otherwise zero. Leaky ReLU allows a small, non-zero gradient for negative inputs.

</details>

### 415. Gradient descent is an optimization algorithm which is commonly-used to \_\_\_\_\_\_ machine learning models and neural networks.

1. Train
2. Test
3. Validate
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Train

**Explanation:**

* **Gradient Descent** is an optimization algorithm used to train machine learning models and neural networks.
* It minimizes the loss function by iteratively adjusting the model's parameters.

</details>

### 416. \_\_\_\_\_\_ is one of the types of gradient descent algorithm.

1. Batch Gradient Descent (BGD)
2. Stochastic Gradient Descent (SGD)
3. Mini-Batch Gradient Descent
4. All of above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of above

**Explanation:**

* **Batch Gradient Descent (BGD)**, **Stochastic Gradient Descent (SGD)**, and **Mini-Batch Gradient Descent** are all variants of the gradient descent algorithm.
* Each variant has its own approach to updating the model's parameters.

</details>

### 417. The backpropagation algorithm is used for which type of neural network?

1. Single-layer feedforward neural networks
2. Multilayer feedforward neural networks
3. Convolutional neural networks
4. Recurrent neural networks

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Multilayer feedforward neural networks

**Explanation:**

* The **backpropagation algorithm** is primarily used in **multilayer feedforward neural networks**.
* It calculates the gradient of the loss function with respect to the weights and propagates the error backward to update the weights.

</details>

### 418. Which of the following is true about the backpropagation algorithm?

1. It is a supervised learning algorithm
2. It is an unsupervised learning algorithm
3. It is a reinforcement learning algorithm
4. It is a semi-supervised learning algorithm

<details>

<summary>Show me the answer</summary>

**Answer:** 1. It is a supervised learning algorithm

**Explanation:**

* The **backpropagation algorithm** is a supervised learning algorithm.
* It requires labeled data to calculate the error and update the model's weights.

</details>

### 419. The backpropagation algorithm involves two phases. What are they?

1. Forward propagation and backward propagation
2. Feature selection and feature extraction
3. Clustering and classification
4. Regression and classification

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Forward propagation and backward propagation

**Explanation:**

* The **backpropagation algorithm** consists of two phases:
  * **Forward propagation**: Input data is passed through the network to compute the output.
  * **Backward propagation**: The error is calculated and propagated backward to update the weights.

</details>

### 420. Which of the following is the activation function commonly used in the backpropagation algorithm?

1. Linear
2. Sigmoid
3. ReLU
4. Tanh

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Sigmoid

**Explanation:**

* The **sigmoid activation function** is commonly used in the backpropagation algorithm.
* It is differentiable, which is essential for calculating gradients during backpropagation.

</details>

### 421. The backpropagation law is also known as generalized delta rule, is it true?

1. Yes
2. No
3. Partially yes
4. Not sure

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Yes

**Explanation:**

* The **backpropagation law** is also known as the **generalized delta rule**.
* It is used to update the weights of a neural network based on the error gradient.

</details>

### 422. \_\_\_\_\_\_ consists of a set of neurons where each neuron corresponds to a pixel of the difference image and is connected to all the neurons in the neighborhood.

1. Hopfield neural network
2. Biological neural network
3. Hamming neural network
4. McColloch Pits' neural network

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Hopfield neural network

**Explanation:**

* The **Hopfield neural network** consists of neurons that are fully connected to each other.
* Each neuron corresponds to a pixel in the input image, and the network is used for tasks like pattern recognition and optimization.

</details>

### 423. The \_\_\_\_\_\_ is commonly used for auto-association and optimization tasks.

1. Hopfield neural network
2. Biological neural network
3. Hamming neural network
4. McColloch Pits' neural network

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Hopfield neural network

**Explanation:**

* The **Hopfield neural network** is commonly used for **auto-association** and **optimization tasks**.
* It can store and retrieve patterns, making it useful for memory-based applications.

</details>

### 424. In \_\_\_\_\_\_, the input and output patterns are discrete vector, which can be either binary 0,1 or bipolar +1, -1 in nature.

1. Continuous Hopfield n/w
2. Discrete Hopfield n/w
3. Sequential Hopfield n/w
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Discrete Hopfield n/w

**Explanation:**

* In a **Discrete Hopfield Network**, the input and output patterns are discrete vectors, typically binary (0, 1) or bipolar (+1, -1).
* It is used for tasks like pattern recognition and associative memory.

</details>

### 425. Continuous Hopfield Network in comparison with Discrete Hopfield network, continuous network has \_\_\_\_\_\_ as a continuous variable.

1. Space
2. Range
3. Time
4. Velocity

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Time

**Explanation:**

* In a **Continuous Hopfield Network**, **time** is treated as a continuous variable.
* This allows the network to model dynamic systems and solve optimization problems more effectively.

</details>

### 426. \_\_\_\_\_\_ architecture can be build up by adding electrical components such as amplifiers which can map the input voltage to the output voltage over a sigmoid activation function.

1. Continuous Hopfield n/w
2. Discrete Hopfield n/w
3. Sequential Hopfield n/w
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Continuous Hopfield n/w

**Explanation:**

* The **Continuous Hopfield Network** can be built using electrical components like amplifiers.
* These components map the input voltage to the output voltage using a sigmoid activation function.

</details>

### 427. \_\_\_\_\_\_, is a network having a single linear unit.

1. Madeline
2. Adaline
3. Backpropagation
4. Perceptron

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Adaline

**Explanation:**

* **Adaline (Adaptive Linear Neuron)** is a neural network with a single linear unit.
* It uses the **Delta Learning Rule** for training and is used for binary classification tasks.

</details>

### 428. The basic structure of \_\_\_\_\_\_ is similar to perceptron having an extra feedback loop.

1. Madeline
2. Adaline
3. Backpropagation
4. None of above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Adaline

**Explanation:**

* The **Adaline** network has a structure similar to the perceptron but includes an extra feedback loop.
* This feedback loop allows it to adjust weights based on the error between the predicted and actual outputs.

</details>

### 429. Identify the diagram and answer the question which training algorithm is this?

A. Madeline B. Adaline\
C. Perceptron D. Backpropagation

<details>

<summary>Show me the answer</summary>

**Answer:** B. Adaline

**Explanation:**

* The diagram represents the **Adaline** training algorithm.
* Adaline uses the **Delta Learning Rule** to minimize the error between the predicted and actual outputs.

</details>

### 430. \_\_\_\_\_\_ is a network which consists of many Adalines in parallel.

1. Madeline
2. Adaline
3. Backpropagation
4. Perceptron

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Madeline

**Explanation:**

* **Madeline (Multiple Adaline)** is a network that consists of multiple Adaline units working in parallel.
* It is used for more complex tasks that require multiple outputs.

</details>

### 431. In NN, Delta rule works only for the \_\_\_\_\_\_.

1. Hidden layer
2. Input layer
3. Weight and bias
4. Output layer

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Output layer

**Explanation:**

* The **Delta Rule** works by adjusting the weights based on the error at the **output layer**.
* It is used to minimize the difference between the predicted and actual outputs.

</details>

### 432. Generalized delta rule, also called as \_\_\_\_\_\_ rule, is a way of creating the desired values of the hidden layer.

1. Feed-forward
2. Backpropagation
3. Perceptron
4. Adaline

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Backpropagation

**Explanation:**

* The **Generalized Delta Rule** is also known as the **Backpropagation Rule**.
* It is used to calculate the error gradients for the hidden layers in a neural network, enabling the network to learn complex patterns.

</details>

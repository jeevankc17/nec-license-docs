# set-11

#### 551. Program ‘preemption’ is:

1. Forced deallocation of the CPU from a program which is executing on the CPU
2. Release of CPU by the program after completing its task
3. Forced allotment of CPU by a program to itself
4. A program terminating itself due to detection of an error

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Forced deallocation of the CPU from a program which is executing on the CPU

**Explanation:**

* **Preemption:** Preemption occurs when the operating system forcibly removes a running process from the CPU to allocate it to another process, typically in a time-sharing system.
* **Conclusion:** Preemption involves forced deallocation of the CPU from a running process.

</details>

#### 552. An assembler is:

1. Programming language dependent
2. Machine dependent
3. Syntax dependent
4. Data dependent

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Machine dependent

**Explanation:**

* **Assembler:** An assembler is a program that converts assembly language code into machine code. It is machine-dependent because the generated machine code is specific to the target processor architecture.
* **Conclusion:** Assemblers are machine-dependent.

</details>

#### 553. Which of the following is not a fundamental process state?

1. Ready
2. Executing
3. Terminated
4. Blocked

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Executing

**Explanation:**

* **Process States:** The fundamental process states are Ready, Running, Blocked, and Terminated. "Executing" is not a standard process state; it is synonymous with the Running state.
* **Conclusion:** Executing is not a fundamental process state.

</details>

#### 554. LRU page replacement policy is:

1. Last Replaced Unit
2. Least Recently Used
3. Last Restored Unit
4. Least Required Unit

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Least Recently Used

**Explanation:**

* **LRU Policy:** The Least Recently Used (LRU) page replacement policy replaces the page that has not been used for the longest time.
* **Conclusion:** LRU stands for Least Recently Used.

</details>

#### 555. Which of the following is true?

1. Block cipher technique is an encryption technique
2. Stream cipher technique is an encryption technique
3. Both (A) and (B)
4. Neither of (A) and (B)

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Both (A) and (B)

**Explanation:**

* **Encryption Techniques:** Block cipher and stream cipher are both encryption techniques. Block cipher encrypts data in fixed-size blocks, while stream cipher encrypts data bit by bit.
* **Conclusion:** Both block cipher and stream cipher are encryption techniques.

</details>

#### 556. Which of the following approaches do not require knowledge of the system state?

1. Deadlock detection
2. Deadlock avoidance
3. Deadlock prevention
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Deadlock prevention

**Explanation:**

* **Deadlock Prevention:** Deadlock prevention techniques do not require knowledge of the system state. They ensure that at least one of the necessary conditions for deadlock (mutual exclusion, hold and wait, no preemption, circular wait) is never satisfied.
* **Conclusion:** Deadlock prevention does not require knowledge of the system state.

</details>

#### 557. Program generation activity aims at:

1. Automatic generation of program
2. Organize execution of a program written in PL
3. Skips generation of program
4. Speed generation of program

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Automatic generation of program

**Explanation:**

* **Program Generation:** Program generation involves automatically creating programs based on predefined templates or specifications.
* **Conclusion:** Program generation aims at the automatic generation of programs.

</details>

#### 558. Which amongst the following is not an advantage of Distributed systems?

1. Reliability
2. Resource sharing
3. Incremental growth
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. None of the above

**Explanation:**

* **Advantages of Distributed Systems:** Distributed systems offer reliability, resource sharing, and incremental growth. All the listed options are advantages.
* **Conclusion:** None of the options are disadvantages of distributed systems.

</details>

#### 559. An imperative statement:

1. Reserves areas of memory and associates names with them
2. Indicates an action to be performed during execution of assembled program
3. Indicates an action to be performed during optimization
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Indicates an action to be performed during execution of assembled program

**Explanation:**

* **Imperative Statement:** An imperative statement in assembly language specifies an action to be performed during the execution of the program.
* **Conclusion:** Imperative statements indicate actions to be performed during execution.

</details>

#### 560. Which of the following loader is executed when a system is first turned on or restarted?

1. Boot loader
2. Bootstrap loader
3. Compile and Go loader
4. Relating loader

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Bootstrap loader

**Explanation:**

* **Bootstrap Loader:** The bootstrap loader is a small program that runs when the system is first turned on or restarted. It loads the operating system into memory.
* **Conclusion:** The bootstrap loader is executed during system startup.

</details>

#### 561. Poor response time is usually caused by:

1. Process busy
2. High paging rate
3. High I/O rates
4. Any of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Any of the above

**Explanation:**

* **Poor Response Time:** Poor response time can be caused by a busy process, high paging rates, or high I/O rates, as all these factors can delay the execution of user requests.
* **Conclusion:** Any of the listed factors can cause poor response time.

</details>

#### 562. The “blocking factor” of a file is:

1. The number of blocks accessible to a file
2. The number of blocks allocated to a file
3. The number of logical records in one physical record
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. The number of logical records in one physical record

**Explanation:**

* **Blocking Factor:** The blocking factor is the number of logical records stored in one physical block or record.
* **Conclusion:** The blocking factor refers to the number of logical records in one physical record.

</details>

#### 563. Which of these is a component of a process precedence sequence?

1. Process name
2. Concurrency operator
3. Sequence operator ';'
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Process Precedence Sequence:** A process precedence sequence includes process names, concurrency operators, and sequence operators to define the order of process execution.
* **Conclusion:** All the listed options are components of a process precedence sequence.

</details>

#### 564. Which amongst the following is valid syntax of the Fork and Join Primitive?

1. Fork
2. For
3. Fork
4. Fork

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Fork

**Explanation:**

* **Fork and Join Primitive:** The Fork and Join primitives are used in parallel programming. The valid syntax for Fork is `Fork <label>`, where `<label>` specifies the starting point of the new process.
* **Conclusion:** The correct syntax is `Fork <label>`.

</details>

#### 565. Nested Macro calls are expanded using the:

1. FIFO rule (First in first out)
2. FILO rule (First in last out)
3. LIFO (Last in First out)
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. LIFO (Last in First out)

**Explanation:**

* **Nested Macro Calls:** Nested macro calls are expanded using the Last In First Out (LIFO) rule, similar to a stack.
* **Conclusion:** LIFO is used for expanding nested macro calls.

</details>

#### 566. A parser which is a variant of top-down parsing without backtracking is:

1. Recursive Descent
2. LL(1) parser
3. Operator Precedence
4. LALR Parser

<details>

<summary>Show me the answer</summary>

**Answer:** 2. LL(1) parser

**Explanation:**

* **LL(1) Parser:** The LL(1) parser is a variant of top-down parsing that does not require backtracking. It uses a lookahead of one token to make parsing decisions.
* **Conclusion:** The LL(1) parser is a top-down parser without backtracking.

</details>

#### 567. The expansion of nested macro calls follows:

1. FIFO rule
2. LILO rule
3. LIFO rule
4. Priority rule

<details>

<summary>Show me the answer</summary>

**Answer:** 3. LIFO rule

**Explanation:**

* **Nested Macro Calls:** Nested macro calls are expanded using the Last In First Out (LIFO) rule, similar to a stack.
* **Conclusion:** LIFO is used for expanding nested macro calls.

</details>

#### 568. In a two-pass assembler, the task of the Pass II is to:

1. Separate the symbol, mnemonic opcode, and operand fields
2. Build the symbol table
3. Construct intermediate code
4. Synthesize the target program

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Synthesize the target program

**Explanation:**

* **Pass II of Assembler:** In a two-pass assembler, Pass II synthesizes the target program by generating machine code using the symbol table built in Pass I.
* **Conclusion:** Pass II synthesizes the target program.

</details>

#### 569. A linker program:

1. Places the program in the memory for the purpose of execution
2. Relocates the program to execute from the specific memory area allocated to it
3. Links the program with other programs needed for its execution
4. Interfaces the program with the entities generating its input data

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Links the program with other programs needed for its execution

**Explanation:**

* **Linker Program:** The linker combines object modules into a single executable program and resolves external references between them.
* **Conclusion:** The linker links the program with other programs needed for its execution.

</details>

#### 570. Which scheduling policy is most suitable for a time-shared operating system?

1. Shortest-job First
2. Round-Robin
3. Elevator
4. First-Come-First-Serve

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Round-Robin

**Explanation:**

* **Time-Shared Systems:** Round-Robin scheduling is most suitable for time-shared systems because it provides fair CPU allocation to all processes by giving each process a fixed time slice (quantum).
* **Conclusion:** Round-Robin is ideal for time-shared operating systems.

</details>

#### 571. A critical section is a program segment:

1. Which should run in a certain specified amount of time
2. Which avoids deadlocks
3. Where shared resources are accessed
4. Which must be enclosed by a pair of semaphore operations, P and V

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Where shared resources are accessed

**Explanation:**

* **Critical Section:** A critical section is a segment of code where shared resources are accessed. It must be executed atomically to prevent race conditions.
* **Conclusion:** The critical section is where shared resources are accessed.

</details>

#### 572. An operating system contains 3 user processes each requiring 2 units of resource R. The minimum number of units of R such that no deadlocks will ever arise is:

1. 4
2. 3
3. 5
4. 6

<details>

<summary>Show me the answer</summary>

**Answer:** 1. 4

**Explanation:**

*   **Deadlock Prevention:** To prevent deadlock, the system must ensure that the total number of resources is sufficient to satisfy the maximum demand of at least one process. For $$n$$ processes, each requiring $$k$$ units of a resource, the minimum number of resources required to avoid deadlock is given by:

    $$
    \text{Minimum Resources} = n \times (k - 1) + 1
    $$

    For 3 processes, each requiring 2 units:

    $$
    \text{Minimum Resources} = 3 \times (2 - 1) + 1 = 4
    $$
* **Conclusion:** The minimum number of units of R required to avoid deadlock is 4.

</details>

#### 573. Locality of reference implies that the page reference being made by a process:

1. Will always be to the page used in the previous page reference
2. Is likely to be the one of the pages used in the last few page references
3. Will always be to one of the pages existing in memory
4. Will always lead to a page fault

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Is likely to be the one of the pages used in the last few page references

**Explanation:**

* **Locality of Reference:** Locality of reference refers to the tendency of a program to access the same set of memory locations repeatedly over a short period of time. This property can be spatial (nearby locations) or temporal (recently accessed locations).
* **Conclusion:** Locality of reference implies that a process is likely to access pages used in the last few references.

</details>

#### 574. This of these is not a part of Synthesis phase:

1. Obtain machine code corresponding to the mnemonic from the Mnemonics table
2. Obtain address of a memory operand from the symbol table
3. Perform LC processing
4. Synthesize a machine instruction or the machine form of a constant

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Perform LC processing

**Explanation:**

* **Synthesis Phase:** The synthesis phase of an assembler involves generating machine code from assembly instructions. LC (Location Counter) processing is part of the analysis phase, not the synthesis phase.
* **Conclusion:** LC processing is not part of the synthesis phase.

</details>

#### 575. The syntax of the assembler directive EQU is:

1. EQU
2. EQU
3. EQU
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. EQU

**Explanation:**

* **EQU Directive:** The EQU directive in assembly language is used to define a symbol and assign it a value. The correct syntax is `<symbol> EQU <address space>`.
* **Conclusion:** The correct syntax is `<symbol> EQU <address space>`.

</details>

#### 576. The following features are needed to implement top-down parsing:

1. Source string marker
2. Matching and Backtracking
3. Prediction making mechanism
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Top-Down Parsing:** Top-down parsing requires a source string marker, matching and backtracking, and a prediction-making mechanism to determine the correct production rule.
* **Conclusion:** All the listed features are needed for top-down parsing.

</details>

#### 577. A macro definition consists of:

1. Macro prototype statement
2. Macro pre-processor statements
3. One or more model statements
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Macro Definition:** A macro definition includes a macro prototype statement, macro pre-processor statements, and one or more model statements.
* **Conclusion:** All the listed components are part of a macro definition.

</details>

#### 578. The main reason to encrypt a file is to:

1. Reduce its size
2. Prepare it for backup
3. Secure it for transmission
4. Include it in the start-up sequence

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Secure it for transmission

**Explanation:**

* **File Encryption:** The primary purpose of encrypting a file is to secure it during transmission or storage, preventing unauthorized access.
* **Conclusion:** Encryption is used to secure files for transmission.

</details>

#### 579. This of the following is not a key piece of information, stored in a single page table entry, assuming pure paging and virtual memory:

1. Frame number
2. A bit indicating whether the page is in physical memory or on the disk
3. A reference for the disk block that stores the page
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. A reference for the disk block that stores the page

**Explanation:**

* **Page Table Entry:** A page table entry typically includes the frame number and a bit indicating whether the page is in memory or on disk. It does not include a reference to the disk block.
* **Conclusion:** A reference to the disk block is not stored in a page table entry.

</details>

#### 580. A UNIX device driver is:

1. Structured into two halves called top half and bottom half
2. Three equal partitions
3. Unstructured
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Structured into two halves called top half and bottom half

**Explanation:**

* **UNIX Device Driver:** A UNIX device driver is structured into two halves: the top half (interrupt handler) and the bottom half (deferred processing).
* **Conclusion:** UNIX device drivers are structured into top and bottom halves.

</details>

#### 581. The following is not a layer of IO management module:

1. PIOCS (Physical Input Output Control System)
2. LIOCS (Logical Input Output Control System)
3. FS (File System)
4. MCS (Management Control System)

<details>

<summary>Show me the answer</summary>

**Answer:** 4. MCS (Management Control System)

**Explanation:**

* **IO Management Module:** The IO management module includes PIOCS, LIOCS, and FS. MCS is not a standard layer of the IO management module.
* **Conclusion:** MCS is not part of the IO management module.

</details>

#### 582. Which amongst the following is not a valid page replacement policy?

1. LRU policy (Least Recently Used)
2. FIFO policy (First in first out)
3. RU policy (Recurrently used)
4. Optimal page replacement policy

<details>

<summary>Show me the answer</summary>

**Answer:** 3. RU policy (Recurrently used)

**Explanation:**

* **Page Replacement Policies:** LRU, FIFO, and Optimal are valid page replacement policies. RU (Recurrently Used) is not a standard policy.
* **Conclusion:** RU is not a valid page replacement policy.

</details>

#### 583. Consider a program with a linked origin of 5000. Let the memory area allocated to it have the start address of 70000. Which amongst the following will be the value to be loaded in the relocation register?

1. 20000
2. 50000
3. 70000
4. None of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. None of the above

**Explanation:**

*   **Relocation Register:** The relocation register contains the difference between the linked origin and the actual start address. Here:

    $$
    \text{Relocation Register} = 70000 - 5000 = 65000
    $$
* **Conclusion:** The correct value is 65000, which is not listed in the options.

</details>

#### 584. An assembly language is a:

1. Low-level programming language
2. Middle-level programming language
3. High-level programming language
4. Internet-based programming language

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Low-level programming language

**Explanation:**

* **Assembly Language:** Assembly language is a low-level programming language that is closely related to machine code and provides direct control over hardware.
* **Conclusion:** Assembly language is a low-level programming language.

</details>

#### 585. TII stands for:

1. Table of Incomplete Instructions
2. Table of Information Instructions
3. Translation of Instructions Information
4. Translation of Information Instruction

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Table of Incomplete Instructions

**Explanation:**

* **TII:** TII stands for Table of Incomplete Instructions, which is used in assembly language processing to track instructions that are not fully resolved.
* **Conclusion:** TII refers to the Table of Incomplete Instructions.

</details>

#### 586. An analysis, which determines the syntactic structure of the source statement, is called:

1. Semantic Analysis
2. Syntax Analysis
3. Process Analysis
4. Function Analysis

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Syntax Analysis

**Explanation:**

* **Syntax Analysis:** Syntax analysis is the phase of compilation that checks the syntactic structure of source code to ensure it conforms to the language's grammar rules.
* **Conclusion:** Syntax analysis determines the syntactic structure of source statements.

</details>

#### 587. Actions implementing instruction’s meaning are actually carried out by:

1. Instruction Fetch
2. Instruction Execution
3. Instruction Decode
4. Instruction Program

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Instruction Execution

**Explanation:**

* **Instruction Execution:** The execution phase of the CPU carries out the actions specified by the instruction, such as performing arithmetic operations or accessing memory.
* **Conclusion:** Instruction execution implements the meaning of instructions.

</details>

#### 588. The field that contains a segment index or an internal index is called:

1. Target Datum
2. Segment Field
3. Target Offset
4. Fis Data

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Segment Field

**Explanation:**

* **Segment Field:** In segmented memory systems, the segment field contains the segment index or internal index used to locate the segment in memory.
* **Conclusion:** The segment field contains the segment index.

</details>

#### 589. A program in execution is called:

1. Process
2. CPU
3. Function
4. Memory

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Process

**Explanation:**

* **Process:** A process is an instance of a program in execution. It includes the program code, data, and resources allocated to it.
* **Conclusion:** A program in execution is called a process.

</details>

#### 590. Jobs which are admitted to the system for processing are called:

1. Long-term scheduling
2. Medium-term scheduling
3. Short-term scheduling
4. Queuing

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Long-term scheduling

**Explanation:**

* **Long-Term Scheduling:** Long-term scheduling involves admitting jobs to the system and placing them in the job queue for processing.
* **Conclusion:** Jobs admitted to the system are handled by long-term scheduling.

</details>

#### 591. A set of techniques that allow executing a program which is not entirely in memory is called:

1. Demand Paging
2. Auxiliary Memory
3. Virtual Memory
4. Secondary Memory

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Virtual Memory

**Explanation:**

* **Virtual Memory:** Virtual memory is a technique that allows a program to execute even if it is not entirely loaded into physical memory. It uses paging or segmentation to manage memory.
* **Conclusion:** Virtual memory enables programs to execute without being fully loaded into memory.

</details>

#### 592. SSTF stands for:

1. Shortest-Seek-Time-First scheduling
2. Simple-Seek-Time-First
3. Small–Small-Time-First
4. Small-Simple-Time-First scheduling

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Shortest-Seek-Time-First scheduling

**Explanation:**

* **SSTF:** SSTF (Shortest-Seek-Time-First) is a disk scheduling algorithm that selects the request with the shortest seek time from the current head position.
* **Conclusion:** SSTF stands for Shortest-Seek-Time-First scheduling.

</details>

#### 593. Before proceeding with its execution, each process must acquire all the resources it needs is called:

1. Hold and Wait
2. Circular Wait
3. No Pre-emption
4. Starvation

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Hold and Wait

**Explanation:**

* **Hold and Wait:** Hold and wait is a condition for deadlock where a process holds at least one resource and waits for additional resources.
* **Conclusion:** Hold and wait describes a process acquiring all needed resources before execution.

</details>

#### 594. Relocation bits used by relocating loader are specified by:

1. Relocating loader itself
2. Macro processor
3. Assembler or Translator
4. Both (A) and (B)

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Assembler or Translator

**Explanation:**

* **Relocation Bits:** Relocation bits are specified by the assembler or translator to indicate which parts of the program need to be relocated during loading.
* **Conclusion:** The assembler or translator specifies relocation bits.

</details>

#### 595. Resolution of externally defined symbols is performed by:

1. Linker
2. Compiler
3. Loader
4. Editor

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Linker

**Explanation:**

* **Linker:** The linker resolves externally defined symbols by combining object modules and resolving references between them.
* **Conclusion:** The linker performs resolution of externally defined symbols.

</details>

#### 596. Relocation programs:

1. Cannot be used with fixed partitions
2. Can be loaded almost anywhere in memory
3. Do not need a linker
4. Can be loaded only at one specific location

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Can be loaded almost anywhere in memory

**Explanation:**

* **Relocation Programs:** Relocation programs can be loaded into different memory locations because they use relative addressing.
* **Conclusion:** Relocation programs can be loaded almost anywhere in memory.

</details>

#### 597. Authentication is a fundamental building block in most computers:

1. Security Context
2. Execution Context
3. Control Context
4. Performance Context

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Security Context

**Explanation:**

* **Authentication:** Authentication verifies the identity of users or systems and is a fundamental part of computer security.
* **Conclusion:** Authentication is part of the security context.

</details>

#### 598. Page fault frequency in an operating system is reduced when the:

1. Processes tend to be I/O-bound
2. Size of pages is reduced
3. Processes tend to be CPU-bound
4. Locality of reference is applicable to the process

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Locality of reference is applicable to the process

**Explanation:**

* **Locality of Reference:** If a process exhibits strong locality of reference, it accesses the same set of memory locations repeatedly, reducing page faults.
* **Conclusion:** Locality of reference reduces page fault frequency.

</details>

#### 599. Which of the following are language processors?

1. Assembler
2. Interpreter
3. Compiler
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Language Processors:** Assemblers, interpreters, and compilers are all language processors that convert high-level or assembly code into machine code.
* **Conclusion:** All of the above are language processors.

</details>

#### 600. Virtual memory can be implemented with:

1. Segmentation
2. None
3. Paging
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Virtual Memory Implementation:** Virtual memory can be implemented using paging, segmentation, or a combination of both.
* **Conclusion:** Virtual memory can be implemented with paging, segmentation, or both.

</details>

# set-3

#### 101. \_\_\_\_\_\_ are white box testing techniques.

1. Statement coverage testing
2. Decision coverage testing
3. Data flow testing
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* White box testing techniques include statement coverage (testing every statement), decision coverage (testing every decision point), and data flow testing (testing the flow of data through the program). All these techniques focus on the internal structure of the code.

</details>

#### 102. In \_\_\_\_\_\_ environment the Alpha Testing can be performed.

1. User’s end
2. Developer’s end
3. User’s and developer’s end
4. Competitor’s end

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Developer’s end

**Explanation:**

* Alpha testing is performed at the developer's end in a controlled environment before the software is released to external users. It is an early stage of testing to identify major issues.

</details>

#### 103. \_\_\_\_\_\_ is not a part of the Test Plan.

1. Schedule
2. Risk Occurrence
3. Incident reports
4. Entry and exit criteria

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Incident reports

**Explanation:**

* Incident reports are not part of the test plan. The test plan includes the schedule, risk occurrence, and entry/exit criteria, which define the scope and approach of testing.

</details>

#### 104. \_\_\_\_\_\_ is the key objective of Integration testing.

1. Specification Errors
2. Interface Errors
3. Validation Errors
4. Procedure Errors

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Interface Errors

**Explanation:**

* The key objective of integration testing is to identify interface errors between different modules or components of the system. It ensures that the integrated components work together as expected.

</details>

#### 105. Exploratory testing is a \_\_\_\_\_\_?

1. Experience-based Test Design Technique
2. White as well as black box Test Design Technique
3. Black Box Test Design Technique
4. Grey Box as well as white box Test Design Technique

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Experience-based Test Design Technique

**Explanation:**

* Exploratory testing is an experience-based testing technique where testers explore the application without predefined test cases. It relies on the tester's knowledge, intuition, and creativity to identify defects.

</details>

#### 106. White Box techniques are also classified as

1. Design based testing
2. Structural testing
3. Error guessing technique
4. Graph based technique

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Structural testing

**Explanation:**

* White box testing techniques are also known as structural testing because they focus on the internal structure of the code, such as control flow, data flow, and logic.

</details>

#### 107. \_\_\_\_\_\_ is/are White box technique.

1. Basis path Testing
2. Decision tree Testing
3. Condition Coverage
4. All of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the mentioned

**Explanation:**

* White box testing techniques include basis path testing (testing all possible paths), decision tree testing (testing decision points), and condition coverage (testing all conditions). All these techniques focus on the internal logic of the code.

</details>

#### 108. \_\_\_\_\_\_ testing comes under the testing of individual components by the developers.

1. Integration testing
2. Validation testing
3. Unit testing
4. System testing

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Unit testing

**Explanation:**

* Unit testing is performed by developers to test individual components or units of code. It ensures that each unit functions correctly in isolation before integration with other components.

</details>

#### 109. The testing have been stopped When \_\_\_\_\_\_.

1. The faults have been fixed
2. All the tests run
3. The time completed
4. The risk are resolved

<details>

<summary>Show me the answer</summary>

**Answer:** 4. The risk are resolved

**Explanation:**

* Testing is typically stopped when the risks associated with the software have been resolved, and the software meets the required quality standards. Fixing faults and running all tests are part of the process, but the ultimate goal is risk mitigation.

</details>

#### 110. Which one is the reputed testing standard?

1. QAI
2. M Bridge awards
3. ISO
4. Microsoft

<details>

<summary>Show me the answer</summary>

**Answer:** 3. ISO

**Explanation:**

* ISO (International Organization for Standardization) is a globally recognized standard for various industries, including software testing. ISO standards ensure quality and consistency in testing processes.

</details>

#### 111. \_\_\_\_\_\_ testing is performed at first.

1. Regression testing
2. Acceptance testing
3. White box testing
4. Static testing

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Static testing

**Explanation:**

* Static testing is performed first, as it involves reviewing documents, code, and designs without executing the software. It helps identify defects early in the development process.

</details>

#### 112. In \_\_\_\_\_\_ testing, the code of the program is checked.

1. Black box testing
2. White box testing
3. Acceptance testing
4. Green box testing

<details>

<summary>Show me the answer</summary>

**Answer:** 2. White box testing

**Explanation:**

* White box testing involves checking the internal code of the program. It focuses on the structure, logic, and flow of the code to ensure it functions as intended.

</details>

#### 113. \_\_\_\_\_\_ testing is done without planning and Documentation.

1. Unit testing
2. Performance testing
3. Adhoc testing
4. Alpha testing

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Adhoc testing

**Explanation:**

* Adhoc testing is performed without formal planning or documentation. It is an informal testing approach where testers explore the application to find defects based on their intuition and experience.

</details>

#### 114. Acceptance testing is also known as

1. Basis path testing
2. BVA testing
3. Alpha Testing
4. Beta testing

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Beta testing

**Explanation:**

* Acceptance testing is also known as beta testing when it is performed by end-users in a real-world environment. It ensures that the software meets the user's requirements and is ready for deployment.

</details>

#### 115. \_\_\_\_\_\_ is non-functional testing.

1. Black box testing
2. Performance testing
3. Unit testing
4. None of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Performance testing

**Explanation:**

* Performance testing is a type of non-functional testing that evaluates how the system performs under various conditions, such as load, stress, and scalability. It focuses on system behavior rather than functionality.

</details>

#### 116. \_\_\_\_\_\_ is black box testing.

1. Decision tree, control structure testing
2. Boundary value analysis, Equivalence partitioning
3. Code path analysis, Alpha testing
4. Control structure, Cause effect graph

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Boundary value analysis, Equivalence partitioning

**Explanation:**

* Boundary value analysis and equivalence partitioning are black box testing techniques. They focus on input values and their impact on the system's behavior without considering the internal code structure.

</details>

#### 117. What is the best time to perform Regression testing?

1. After the software has been modified
2. As soon as possible
3. When the environment has been modified
4. Both option A & C

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both option A & C

**Explanation:**

* Regression testing should be performed after the software has been modified or when the environment has been modified. This ensures that the changes have not introduced new defects or broken existing functionality.

</details>

#### 118. Does the customer get a 100% bug-free product?

1. Product is old
2. Developers are super
3. The testing team is not good
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. The testing team is not good

**Explanation:**

* It is nearly impossible to deliver a 100% bug-free product due to the complexity of software systems. However, a good testing team can significantly reduce the number of defects and improve software quality.

</details>

#### 119. \_\_\_\_\_\_ Test Document is used to define the Exit Criteria of Testing.

1. Incident Report
2. Test Summary Report
3. Debug report
4. Test Plan

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Test Plan

**Explanation:**

* The Test Plan document defines the exit criteria for testing, which specify the conditions that must be met for testing to be considered complete. It outlines the scope, approach, and objectives of testing.

</details>

#### 120. \_\_\_\_\_\_ is not the right approach of Incremental testing approach.

1. Big bang approach
2. Top-down approach
3. Functional incrimination
4. Bottom-up approach

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Big bang approach

**Explanation:**

* The big bang approach is not an incremental testing approach. Incremental testing involves testing components in small increments, such as top-down, bottom-up, or functional incrementation.

</details>

#### 121. The test levels are performed in \_\_\_\_\_\_ of the following order.

1. Unit, Integration, System, Acceptance
2. It is based on the nature of the project
3. Unit, Integration, Acceptance, System
4. Unit, System, Integration, Acceptance

<details>

<summary>Show me the answer</summary>

**Answer:** 2. It is based on the nature of the project

**Explanation:**

* The order of test levels (unit, integration, system, acceptance) can vary based on the nature of the project. The specific sequence depends on the project's requirements and development approach.

</details>

#### 122. What is component testing?

1. White-box testing
2. Grey box testing
3. Black box testing
4. Both A & C

<details>

<summary>Show me the answer</summary>

**Answer:** 1. White-box testing

**Explanation:**

* Component testing, also known as unit testing, is a type of white-box testing where individual components or units of code are tested in isolation. It focuses on the internal structure and logic of the code.

</details>

#### 123. Select the correct defect rate for Six sigma?

1. 2.4 defect per million lines of code.
2. 3.14 defects per million lines of code.
3. 3.04 defects per million lines of code.
4. 3.4 million per million lines of code.

<details>

<summary>Show me the answer</summary>

**Answer:** 4. 3.4 million per million lines of code.

**Explanation:**

* Six Sigma aims for a defect rate of 3.4 defects per million opportunities. This is a measure of process quality and indicates a high level of consistency and reliability.

</details>

#### 124. In \_\_\_\_\_\_ Defects removal efficiency (DRE) is dependent

1. E: errors found before software delivery
2. D: defects found after delivery to user
3. Both A and B
4. B: Bugs found during Lifecycle

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Both A and B

**Explanation:**

* Defect Removal Efficiency (DRE) is calculated based on the number of errors found before software delivery (E) and defects found after delivery to the user (D). It measures the effectiveness of the testing process in identifying and removing defects.

</details>

#### 125. \_\_\_\_\_\_ is an indirect measure of product?

1. Quality
2. Complexity
3. Reliability
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* Quality, complexity, and reliability are indirect measures of a product. They are not directly measurable but are inferred from other metrics and observations.

</details>

#### 126. \_\_\_\_\_\_ is not a direct measure of SE process?

1. Efficiency
2. Benefit
3. Applied Effort
4. Investment

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Efficiency

**Explanation:**

* Efficiency is not a direct measure of the software engineering process. It is a derived metric that depends on other factors like time, cost, and effort. Direct measures include applied effort, investment, and benefits.

</details>

#### 127. Function Point Computation is given by the formula

1. FP = \[count total \* 0.65] + 0.01 \* sum(Fi)
2. FP = count total \* \[0.65 + 0.01 \* sum(Fi)]
3. FP = count total \* \[0.65 + 0.01] \* sum(Fi)
4. FP = \[count total \* 0.65 + 0.01] \* sum(Fi)

<details>

<summary>Show me the answer</summary>

**Answer:** 2. FP = count total \* \[0.65 + 0.01 \* sum(Fi)]

**Explanation:**

* The Function Point (FP) computation formula is given by:\
  $$FP = \text{count total} \times [0.65 + 0.01 \times \sum(Fi)]$$\
  where ( Fi ) represents the complexity adjustment factors.

</details>

#### 128. SMI stands for?

1. Software Mature Indicator
2. Software Maintenance Index
3. Software Maturity Index
4. Software Maturity Indication

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Software Maturity Index

**Explanation:**

* SMI stands for Software Maturity Index, which is a metric used to measure the stability and maturity of a software product over time.

</details>

#### 129. \_\_\_\_\_\_ is the purpose of project metrics.

1. Minimization of development schedule
2. To perform design purposes
3. Access project quality
4. Minimization of development schedule and assessing project quality on ongoing basis

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Minimization of development schedule and assessing project quality on ongoing basis

**Explanation:**

* Project metrics are used to minimize the development schedule and assess project quality on an ongoing basis. They provide insights into the progress and health of the project.

</details>

#### 130. Which of the following is an indirect measure of product?

1. Quality
2. Complexity
3. Reliability
4. All of the Mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the Mentioned

**Explanation:**

* Quality, complexity, and reliability are indirect measures of a product. They are inferred from other metrics and observations rather than being directly measurable.

</details>

#### 131. In size-oriented metrics, metrics are developed based on the \_\_\_\_\_\_

1. Number of Functions
2. Number of user’ requirement
3. Number of lines of code
4. Amount of memory usage

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Number of lines of code

**Explanation:**

* Size-oriented metrics are based on the number of lines of code (LOC). This metric is used to estimate the size and complexity of the software.

</details>

#### 132. Which of the following is not an information domain required for determining function point in FPA?

1. Number of user requirements
2. Number of user Involvement
3. Number of external Interfaces
4. Number of errors

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Number of errors

**Explanation:**

* The number of errors is not part of the information domain required for determining function points in Function Point Analysis (FPA). The information domain includes user requirements, user involvement, and external interfaces.

</details>

#### 133. Size and Complexity are a part of \_\_\_\_\_\_

1. Product Metrics
2. Process Metrics
3. Project Metrics
4. People Metrics

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Product Metrics

**Explanation:**

* Size and complexity are part of product metrics, which focus on the characteristics of the software product itself, such as its size, complexity, and quality.

</details>

#### 134. Number of errors found per person hours expended is an example of a

1. Measurement
2. Measure
3. Metric
4. Quantity

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Metric

**Explanation:**

* The number of errors found per person-hours expended is an example of a metric. It quantifies the efficiency of the testing process in terms of defect detection.

</details>

#### 135. By \_\_\_\_\_\_ reason, the software is delivered late.

1. Changing customer requirements frequently.
2. Technical difficulties that came during the devolvement of the product
3. Human difficulties that could not have been foreseen in advance
4. All of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the mentioned

**Explanation:**

* Software delivery delays can occur due to changing customer requirements, technical difficulties, and unforeseen human challenges. All these factors can impact the project timeline.

</details>

#### 136. Which of the following is an activity that distributes estimated effort across the planned project duration by allocating the effort to specific software engineering tasks?

1. Software Macroscopic schedule
2. Software Project scheduling
3. Software Detailed schedule
4. Software Quality schedule

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Software Project scheduling

**Explanation:**

* Software Project scheduling involves distributing the estimated effort across the project duration and allocating it to specific tasks. It ensures that the project is completed on time and within budget.

</details>

#### 137. Every task that is scheduled should be assigned to a specific team member is termed as

1. Defined Checkpoints
2. Defined milestones
3. Defined responsibilities
4. Defined customer requirements

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Defined responsibilities

**Explanation:**

* Assigning every scheduled task to a specific team member is termed as defined responsibilities. It ensures accountability and clarity in task ownership.

</details>

#### 138. What is the recommended distribution of effort for a project?

1. 40-20-40
2. 30-20-500
3. 20-20-60
4. 50-30-20

<details>

<summary>Show me the answer</summary>

**Answer:** 1. 40-20-40

**Explanation:**

* The recommended distribution of effort for a project is 40% for analysis and design, 20% for coding, and 40% for testing and maintenance. This ensures a balanced approach to software development.

</details>

#### 139. Which technique is applicable when other projects in the same analogy application domain have been completed?

1. Algorithmic cost modelling
2. Pareto principles
3. Estimation by analogy
4. Parkinson’s Law

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Estimation by analogy

**Explanation:**

* Estimation by analogy is a technique used when other projects in the same application domain have been completed. It involves comparing the current project with similar past projects to estimate effort, cost, and duration.

</details>

#### 140. The COCOMO model takes into account different approaches to software development, reuse, etc.

1. True
2. False

<details>

<summary>Show me the answer</summary>

**Answer:** 1. True

**Explanation:**

* The COCOMO (Constructive Cost Model) takes into account different approaches to software development, including reuse, complexity, and team experience. It is a widely used model for estimating software development effort.

</details>

#### 141. A \_\_\_\_\_\_ is developed using historical cost information that relates some software metric to the project cost.

1. Algorithmic cost modelling
2. Six sigma principles
3. Estimation by analogy
4. Pareto principles

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Algorithmic cost modelling

**Explanation:**

* Algorithmic cost modeling uses historical cost information and software metrics (e.g., lines of code, function points) to estimate project costs. It provides a quantitative approach to cost estimation.

</details>

#### 142. Which of the following uses empirically derived formulas to predict effort as a function of LOC or FP?

1. FP-Based Estimation
2. Process-Based Estimation
3. COCOMO
4. Both FP-Based Estimation and COCOMO

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Both FP-Based Estimation and COCOMO

**Explanation:**

* Both FP-Based Estimation (Function Point Analysis) and COCOMO (Constructive Cost Model) use empirically derived formulas to predict effort as a function of LOC (Lines of Code) or FP (Function Points).

</details>

#### 143. COCOMO stands for

1. Constructive cost model
2. Comprehensive cost model
3. Constructive cost estimation model
4. Cooperative cost estimation model

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Constructive cost model

**Explanation:**

* COCOMO stands for Constructive Cost Model. It is a widely used model for estimating the cost, effort, and schedule of software development projects.

</details>

#### 144. Which version of COCOMO states that once requirements have been stabilized, the basic software architecture has been established?

1. Early design stage model
2. Late design stage model
3. Application development model
4. All of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Early design stage model

**Explanation:**

* The Early Design Stage Model of COCOMO is used when the requirements have been stabilized, and the basic software architecture has been established. It provides initial estimates for effort and cost.

</details>

#### 145. Which model was used during the early stages of software engineering, when prototyping of user interfaces, consideration of software and system interaction, assessment of performance, and evaluation of technology maturity were paramount?

1. Early design stage model
2. Post-architecture-stage model
3. Application composition model
4. All of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Application composition model

**Explanation:**

* The Application Composition Model was used during the early stages of software engineering when prototyping user interfaces, assessing performance, and evaluating technology maturity were critical. It focuses on rapid application development.

</details>

#### 146. Which one is not a size measure for software product?

1. LOC
2. Halstead’s program length
3. Function Count
4. Cyclomatic Complexity

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Cyclomatic Complexity

**Explanation:**

* Cyclomatic Complexity is a measure of the complexity of the control flow in a program, not a size measure. Size measures include LOC (Lines of Code), Halstead’s program length, and Function Count.

</details>

#### 147. COCOMO was developed initially by

1. B.Beizer
2. Roger S. Pressman
3. B.W.Bohein
4. Gregg Rothermal

<details>

<summary>Show me the answer</summary>

**Answer:** 3. B.W.Bohein

**Explanation:**

* COCOMO (Constructive Cost Model) was initially developed by Barry W. Boehm. It is a widely used model for estimating software development effort and cost.

</details>

#### 148. \_\_\_\_\_\_ is not included in failure costs.

1. Rework
2. Repair
3. Failure mode analysis
4. None of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 4. None of the mentioned

**Explanation:**

* Failure costs include rework, repair, and failure mode analysis. These are costs incurred due to defects or failures in the software.

</details>

#### 149. \_\_\_\_\_\_ requirements are the foundation from which quality is measured.

1. Hardware
2. Software
3. Programmers
4. None of the mentioned

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Software

**Explanation:**

* Software requirements are the foundation from which quality is measured. They define what the software should do and how it should perform, serving as the basis for quality assurance.

</details>

#### 150. Which of the following is not a SQA plan for a project?

1. Evaluations to be performed
2. Amount of technical work
3. Audits and reviews to be performed
4. Documents to be produced by the SQA group

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Amount of technical work

**Explanation:**

* The amount of technical work is not part of the Software Quality Assurance (SQA) plan. The SQA plan includes evaluations, audits, reviews, and documentation to ensure quality.

</details>

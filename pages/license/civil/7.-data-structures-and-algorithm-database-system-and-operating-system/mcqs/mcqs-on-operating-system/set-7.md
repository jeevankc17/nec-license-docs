# set-7

#### 301. Most of the microcomputer’s operating systems like Apple DOS, MS DOS, and PC DOS, etc., are called disk operating systems because:

1. They are memory resident
2. They are initially stored on disk
3. They are available on magnetic tapes
4. They are partly in primary memory and partly on disk

<details>

<summary>Show me the answer</summary>

**Answer:** 2. They are initially stored on disk

**Explanation:**

* **Disk Operating Systems:** Disk operating systems (DOS) are called so because they are stored on disk and loaded into memory during system startup.
* **Conclusion:** DOS systems are initially stored on disk.

</details>

#### 302. When did IBM release the first version of the disk operating system DOS version 1.0?

1. 1981
2. 1983
3. 1982
4. 1984

<details>

<summary>Show me the answer</summary>

**Answer:** 1. 1981

**Explanation:**

* **DOS 1.0 Release:** IBM released the first version of DOS (PC-DOS 1.0) in 1981 for the IBM PC.
* **Conclusion:** DOS 1.0 was released in 1981.

</details>

#### 303. IBM released its first PC in 1981. Can you name the operating system which was most popular at that time?

1. MS-DOS
2. OS/360
3. PC-DOS
4. CP/M

<details>

<summary>Show me the answer</summary>

**Answer:** 4. CP/M

**Explanation:**

* **Popular OS in 1981:** CP/M (Control Program for Microcomputers) was the most popular operating system for microcomputers in 1981.
* **Conclusion:** CP/M was the most popular OS at that time.

</details>

#### 304. Page fault frequency in an operating system is reduced when the:

1. Size of pages is reduced
2. Processes tend to be I/O-bound
3. Processes tend to be CPU-bound
4. Locality of reference is applicable to the process

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Locality of reference is applicable to the process

**Explanation:**

* **Page Fault Frequency:** Page fault frequency is reduced when processes exhibit strong locality of reference, meaning they access the same set of memory locations repeatedly.
* **Conclusion:** Locality of reference reduces page fault frequency.

</details>

#### 305. Which of the following is true for testing and debugging?

1. Testing checks for logical errors in the programs while debugging is a process of correcting those errors in the programs
2. Testing detects the syntax errors in the program while debugging corrects those errors in the program
3. Testing and debugging indicate the same thing
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Testing checks for logical errors in the programs while debugging is a process of correcting those errors in the programs

**Explanation:**

* **Testing vs Debugging:** Testing involves identifying errors in a program, while debugging involves correcting those errors.
* **Conclusion:** Testing and debugging are distinct but related processes.

</details>

#### 306. If special forms are needed for printing the output, the programmer specifies these forms through:

1. JCL
2. Utility program
3. IPL
4. Load modules

<details>

<summary>Show me the answer</summary>

**Answer:** 1. JCL

**Explanation:**

* **JCL (Job Control Language):** JCL is used to specify special forms or requirements for printing output in batch processing systems.
* **Conclusion:** JCL is used to specify printing forms.

</details>

#### 307. Under multiprogramming, turnaround time for short jobs is usually...... and for long jobs is slightly......

1. Lengthened; shortened
2. Shortened; shortened
3. Shortened; lengthened
4. Lengthened; lengthened

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Shortened; lengthened

**Explanation:**

* **Turnaround Time:** In multiprogramming, short jobs are executed quickly, reducing their turnaround time. Long jobs may experience slightly longer turnaround times due to resource sharing.
* **Conclusion:** Turnaround time is shortened for short jobs and lengthened for long jobs.

</details>

#### 308. The state transition initiated by the user process itself in an operating system is:

1. Block
2. Wake up
3. Dispatch
4. Timer run out

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Block

**Explanation:**

* **State Transition:** A process can transition to the Blocked state when it requests an I/O operation or waits for an event. This transition is initiated by the process itself.
* **Conclusion:** The Block state transition is user-initiated.

</details>

#### 309. Which of the following terms refers to the degree to which data in a database system are accurate and correct?

1. Data security
2. Data independence
3. Data validity
4. Data integrity

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Data integrity

**Explanation:**

* **Data Integrity:** Data integrity refers to the accuracy and consistency of data in a database system.
* **Conclusion:** Data integrity ensures data accuracy and correctness.

</details>

#### 310. The total time to prepare a disk drive mechanism for a block of data to be read from it is:

1. Latency
2. Latency plus transmission time
3. Latency plus seek time
4. Latency plus seek time plus transmission time

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Latency plus seek time

**Explanation:**

* **Disk Access Time:** The total time to prepare a disk drive for reading data includes seek time (time to move the disk arm to the correct track) and latency (time for the disk to rotate to the correct sector).
* **Conclusion:** The total preparation time is latency plus seek time.

</details>

#### 311. Indicate whether the statement LDA B is a statement in:

1. Machine language
2. High-level language
3. Assembly language
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Assembly language

**Explanation:**

* **LDA B:** LDA (Load Accumulator) is a mnemonic used in assembly language to load data into the accumulator.
* **Conclusion:** LDA B is an assembly language statement.

</details>

#### 312. Indicate which describes the term “software”:

1. Systems programs only
2. Both A and B
3. Application programs only
4. All of the printer

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Both A and B

**Explanation:**

* **Software:** Software includes both system programs (e.g., operating systems) and application programs (e.g., word processors).
* **Conclusion:** Software encompasses both system and application programs.

</details>

#### 313. Bug means:

1. A logical error in a program
2. A difficult syntax error in a program
3. Documenting programs using an efficient documentation tool
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. A logical error in a program

**Explanation:**

* **Bug:** A bug refers to a logical error in a program that causes it to behave incorrectly.
* **Conclusion:** Bugs are logical errors in programs.

</details>

#### 314. A development strategy whereby the executive control modules of a system are coded and tested first is known as:

1. Bottom-up development
2. Left-Right development
3. Top-down development
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Top-down development

**Explanation:**

* **Top-Down Development:** In top-down development, high-level modules (e.g., executive control modules) are developed and tested first, followed by lower-level modules.
* **Conclusion:** Top-down development starts with executive control modules.

</details>

#### 315. Indicate which, of the following, is not true about Nassi-Shneiderman charts:

1. These charts are a type of graphical design tool
2. These charts cannot represent CASE constructs
3. These charts can represent three fundamental control structures
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. These charts cannot represent CASE constructs

**Explanation:**

* **Nassi-Shneiderman Charts:** These charts are graphical design tools that can represent fundamental control structures (e.g., sequence, selection, iteration) and CASE constructs.
* **Conclusion:** Nassi-Shneiderman charts can represent CASE constructs.

</details>

#### 316. Indicate which, of the following, is not true about a data flow diagram (DFD):

1. It is a graphical representation of the flow of data through the system
2. It is used to analyze any system or software at any level of abstraction
3. It is a very important tool, used by system analysts and designers
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Data Flow Diagram (DFD):** A DFD is a graphical tool used to represent the flow of data in a system. It is used at various levels of abstraction and is essential for system analysis and design.
* **Conclusion:** All the statements about DFDs are true.

</details>

#### 317. Which of the following checks cannot be carried out on the input data to a system?

1. Consistency check
2. Range checks
3. Syntax check
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Input Data Checks:** Consistency checks, range checks, and syntax checks are all valid methods for validating input data.
* **Conclusion:** All the checks can be performed on input data.

</details>

#### 318. Which of the following is not true about documentation?

1. Documentation of a system should be as clear and direct as possible
2. Documentation increases the maintenance time and cost
3. Documentation gives a better understanding of the problem
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Documentation increases the maintenance time and cost

**Explanation:**

* **Documentation:** Proper documentation reduces maintenance time and cost by providing clear and direct information about the system.
* **Conclusion:** Documentation does not increase maintenance time and cost.

</details>

#### 319. C is:

1. An assembly language
2. A third-generation high-level language
3. A machine language
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. A third-generation high-level language

**Explanation:**

* **C Language:** C is a third-generation high-level programming language known for its efficiency and flexibility.
* **Conclusion:** C is a high-level language.

</details>

#### 320. Which of the following modules does not incorporate initialization of values changed by the module?

1. Non-reusable module
2. Reentrant module
3. Serially reusable module
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Non-reusable module

**Explanation:**

* **Non-Reusable Module:** A non-reusable module does not incorporate initialization of values changed by the module, making it unsafe for reuse.
* **Conclusion:** Non-reusable modules do not initialize changed values.

</details>

#### 321. Which of the following statements is false?

1. A process scheduling algorithm is preemptive if the CPU can be forcibly removed from a process
2. Time-sharing systems generally use preemptive CPU scheduling
3. Response times are more predictable in preemptive systems than in non-preemptive systems
4. Real-time systems generally use non-preemptive CPU scheduling

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Real-time systems generally use non-preemptive CPU scheduling

**Explanation:**

* **Real-Time Systems:** Real-time systems typically use preemptive scheduling to ensure timely execution of critical tasks.
* **Conclusion:** Real-time systems use preemptive scheduling, not non-preemptive.

</details>

#### 322. Indicate which, of the following, is not true about an interpreter:

1. Interpreter generates an object program from the source program
2. Interpreter is a kind of translator
3. Interpreter analyzes each source statement every time it is to be executed
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Interpreter generates an object program from the source program

**Explanation:**

* **Interpreter:** An interpreter executes source code directly without generating an object program. It analyzes and executes each statement at runtime.
* **Conclusion:** Interpreters do not generate object programs.

</details>

#### 323. Indicate which, of the following, is not true about 4GL:

1. 4GL does not support a high level of screen interaction
2. Many database management system packages support 4GL
3. A 4GL is a software tool which is written possibly in some third-generation language
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. 4GL does not support a high level of screen interaction

**Explanation:**

* **4GL (Fourth-Generation Language):** 4GLs are designed for high-level programming and often support advanced screen interaction and database management.
* **Conclusion:** 4GLs support a high level of screen interaction.

</details>

#### 324. An algorithm is described as:

1. A computer language
2. A step-by-step procedure for solving a problem
3. A branch of mathematics
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. A step-by-step procedure for solving a problem

**Explanation:**

* **Algorithm:** An algorithm is a step-by-step procedure for solving a problem or performing a task.
* **Conclusion:** Algorithms are problem-solving procedures.

</details>

#### 325. A sequence of instructions, in a computer language, to get the desired result is known as:

1. Algorithm
2. Program
3. Decision table
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Program

**Explanation:**

* **Program:** A program is a sequence of instructions written in a computer language to achieve a specific result.
* **Conclusion:** A program is a sequence of instructions.

</details>

#### 326. The strategy of allowing processes that are logically runnable to be temporarily suspended is called:

1. Preemptive scheduling
2. Shortest job first
3. Non-preemptive scheduling
4. First come first served

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Preemptive scheduling

**Explanation:**

* **Preemptive Scheduling:** Preemptive scheduling allows the operating system to suspend a running process and allocate the CPU to another process.
* **Conclusion:** Preemptive scheduling involves suspending runnable processes.

</details>

#### 327. Part of a program where the shared memory is accessed and which should be executed indivisibly is called:

1. Semaphores
2. Critical section
3. Directory
4. Mutual exclusion

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Critical section

**Explanation:**

* **Critical Section:** The critical section is the part of a program where shared resources are accessed. It must be executed indivisibly to prevent race conditions.
* **Conclusion:** The critical section is where shared memory is accessed.

</details>

#### 328. The technique, for sharing the time of a computer among several jobs, which switches jobs so rapidly such that each job appears to have the computer to itself is:

1. Time sharing
2. Time domain
3. Time out
4. FIFO

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Time sharing

**Explanation:**

* **Time Sharing:** Time sharing allows multiple users to share a computer by rapidly switching between jobs, giving the illusion that each user has exclusive access.
* **Conclusion:** Time sharing rapidly switches between jobs.

</details>

#### 329. The operating system manages:

1. Memory
2. Disks and I/O devices
3. Processor
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Operating System Functions:** The operating system manages memory, disks, I/O devices, and the processor to ensure efficient system operation.
* **Conclusion:** The operating system manages all the listed resources.

</details>

#### 330. A form of code that uses more than one process and processor, possibly of different types, and that may on occasion have more than one process or processor active at the same time is known as:

1. Multiprogramming
2. Broadcasting
3. Multithreading
4. Time sharing

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Multithreading

**Explanation:**

* **Multithreading:** Multithreading allows multiple threads within a process to execute concurrently, possibly on multiple processors.
* **Conclusion:** Multithreading uses multiple processes and processors.

</details>

#### 331. Assembly language:

1. Is usually the primary user interface
2. Requires fixed-format commands
3. Is a mnemonic form of machine language
4. Is quite different from the SCL interpreter

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Is a mnemonic form of machine language

**Explanation:**

* **Assembly Language:** Assembly language is a low-level programming language that uses mnemonics to represent machine instructions.
* **Conclusion:** Assembly language is a mnemonic form of machine language.

</details>

#### 332. Which of the following are the advantages of modular programming?

1. The program is much easier to change
2. Modules can be reused in other programs
3. Easy debugging
4. Easy to compile

<details>

<summary>Show me the answer</summary>

**Answer:** 1. The program is much easier to change

**Explanation:**

* **Modular Programming:** Modular programming divides a program into smaller, independent modules, making it easier to modify and maintain.
* **Conclusion:** Modular programming simplifies program changes.

</details>

#### 333. Which of the following can be accessed by the transfer vector approach of linking?

1. External data segments
2. Data located in other procedures
3. External subroutines
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Transfer Vector Approach:** The transfer vector approach allows access to external data segments, data in other procedures, and external subroutines.
* **Conclusion:** All the options can be accessed using the transfer vector approach.

</details>

#### 334. The linker:

1. Is the same as the loader
2. Is required to create a load module
3. Uses source code as input
4. Is always used before programs are executed

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Is required to create a load module

**Explanation:**

* **Linker:** The linker combines object modules into a single load module, resolving external references.
* **Conclusion:** The linker creates load modules.

</details>

#### 335. Indicate which is a pre-emptive scheduling algorithm:

1. Round-robin
2. Priority-based
3. Shortest-job-next
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 4. All of the above

**Explanation:**

* **Pre-emptive Scheduling:** Round-robin, priority-based, and shortest-job-next are all pre-emptive scheduling algorithms.
* **Conclusion:** All the listed algorithms are pre-emptive.

</details>

#### 336. A characteristic of an online real-time system is:

1. More than one CPU
2. Offline batch processing
3. No delay in processing
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 3. No delay in processing

**Explanation:**

* **Real-Time Systems:** Real-time systems are designed to process data without delay, ensuring timely responses.
* **Conclusion:** No delay in processing is a key characteristic of real-time systems.

</details>

#### 337. Indicate which, of the following, is the worst type of module coupling:

1. Content coupling
2. Control coupling
3. No coupling
4. All of the above

<details>

<summary>Show me the answer</summary>

**Answer:** 1. Content coupling

**Explanation:**

* **Module Coupling:** Content coupling is the worst type of coupling, where one module directly modifies the internal data of another module.
* **Conclusion:** Content coupling is the least desirable.

</details>

#### 338. A page fault:

1. Is an error in a specific page
2. Occurs when a program accesses a page of memory
3. Is an access to a page not currently in memory
4. Is a reference to a page belonging to another program

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Is an access to a page not currently in memory

**Explanation:**

* **Page Fault:** A page fault occurs when a program tries to access a page that is not currently in main memory, requiring it to be loaded from secondary storage.
* **Conclusion:** A page fault is an access to a page not in memory.

</details>

#### 339. In memory systems, boundary registers:

1. Are used for temporary program variable storage
2. Are only necessary with fixed partitions
3. Track page boundaries
4. Track the beginning and ending of programs

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Track the beginning and ending of programs

**Explanation:**

* **Boundary Registers:** Boundary registers track the start and end addresses of programs in memory, ensuring memory protection.
* **Conclusion:** Boundary registers track program boundaries.

</details>

#### 340. Relocatable programs:

1. Cannot be used with fixed partitions
2. Can be loaded almost anywhere in memory
3. Do not need a linker
4. Can be loaded only at one specific location

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Can be loaded almost anywhere in memory

**Explanation:**

* **Relocatable Programs:** Relocatable programs can be loaded into any available memory location, as their addresses are adjusted during loading.
* **Conclusion:** Relocatable programs can be loaded anywhere in memory.

</details>

#### 341. The FIFO algorithm:

1. Executes first the job that last entered the queue
2. Executes first the job that first entered the queue
3. Executes first the job that has been in the queue the longest
4. Executes first the job with the least processor needs

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Executes first the job that first entered the queue

**Explanation:**

* **FIFO Algorithm:** FIFO (First-In-First-Out) executes jobs in the order they arrive in the queue.
* **Conclusion:** FIFO executes the first job in the queue.

</details>

#### 342. The user interface:

1. Is relatively unimportant
2. Is slanted toward novice users
3. Supports both novice and experienced users
4. Is easy to provide, even with good support

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Supports both novice and experienced users

**Explanation:**

* **User Interface:** A good user interface is designed to support both novice and experienced users, providing ease of use and advanced features.
* **Conclusion:** The user interface supports all users.

</details>

#### 343. Memory management is:

1. Not used in modern operating systems
2. Replaced with virtual memory on current systems
3. Not used on multiprogramming systems
4. Critical for even the simplest operating systems

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Critical for even the simplest operating systems

**Explanation:**

* **Memory Management:** Memory management is essential for all operating systems, including simple ones, to allocate and manage memory resources efficiently.
* **Conclusion:** Memory management is critical for all operating systems.

</details>

#### 344. The practice of “bundling” refers to:

1. Selling computers alone
2. Selling peripheral devices with computers
3. Selling software to run on computers
4. Giving away software with a computer purchase

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Giving away software with a computer purchase

**Explanation:**

* **Bundling:** Bundling refers to including software with the purchase of a computer, often as an incentive.
* **Conclusion:** Bundling involves giving away software with a computer.

</details>

#### 345. The primary purpose of an operating system is to:

1. Make computers easier to use
2. Keep system programmers employed
3. Make the most efficient use of the hardware
4. Allow people to use the computers

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Make the most efficient use of the hardware

**Explanation:**

* **Operating System Purpose:** The primary purpose of an operating system is to manage hardware resources efficiently and provide a user-friendly interface.
* **Conclusion:** The operating system optimizes hardware usage.

</details>

#### 346. Multiprogramming systems:

1. Are easier to develop than single programming systems
2. Execute each job faster
3. Execute more jobs in the same time period
4. Are used only on large mainframe computers

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Execute more jobs in the same time period

**Explanation:**

* **Multiprogramming:** Multiprogramming allows multiple jobs to reside in memory simultaneously, increasing system throughput by executing more jobs in the same time period.
* **Conclusion:** Multiprogramming increases job execution efficiency.

</details>

#### 347. Spooling is most beneficial in a multiprogramming environment where:

1. Most jobs are CPU-bound
2. Most jobs are I/O-bound
3. Jobs are evenly divided as I/O-bound and CPU-bound
4. There is limited primary memory and need for secondary memory

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Most jobs are I/O-bound

**Explanation:**

* **Spooling:** Spooling (Simultaneous Peripheral Operations On-Line) is most beneficial when most jobs are I/O-bound, as it allows overlapping of I/O operations with CPU processing.
* **Conclusion:** Spooling is ideal for I/O-bound jobs.

</details>

#### 348. Software that measures, monitors, analyzes, and controls real-world events is called:

1. System software
2. Scientific software
3. Real-time software
4. Business software

<details>

<summary>Show me the answer</summary>

**Answer:** 3. Real-time software

**Explanation:**

* **Real-Time Software:** Real-time software is designed to monitor and control real-world events, ensuring timely responses.
* **Conclusion:** Real-time software handles real-world events.

</details>

#### 349. Object modules generated by assemblers that contain unresolved external references are resolved for two or more object modules by a/an:

1. Operating system
2. Linker
3. Loader
4. Compiler

<details>

<summary>Show me the answer</summary>

**Answer:** 2. Linker

**Explanation:**

* **Linker:** The linker resolves external references between object modules, combining them into a single executable program.
* **Conclusion:** The linker resolves external references.

</details>

#### 350. Which of the following is false about disk when compared to main memory?

1. Non-volatile
2. Lower price per bit
3. Longer storage capacity
4. Faster

<details>

<summary>Show me the answer</summary>

**Answer:** 4. Faster

**Explanation:**

* **Disk vs Main Memory:** Disks are non-volatile, cheaper per bit, and have larger storage capacity, but they are slower than main memory.
* **Conclusion:** Disks are slower than main memory.

</details>
